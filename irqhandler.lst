ca65 V2.13.2 - (C) Copyright 1998-2005 Ullrich von Bassewitz
Main file   : irqhandler.as
Current file: irqhandler.as

000000r 1                       ;;
000000r 1                       ;; irqhandler.as
000000r 1                       ;;
000000r 1                       ;; save full state of 816 and call a 6502-mode irq handler
000000r 1               	;;
000000r 1               	;; 816 irq is vectored to (ffee) which on a beeb os1.20 is 0e6c
000000r 1               	;;
000000r 1               	;; build with:
000000r 1               	;;   make -B BASE=0x4000 irqhandler.srec
000000r 1               	;;
000000r 1               	;; results in run65816 demonstrates IRQs are handled without disaster:
000000r 1               	;; >CALL&4000
000000r 1               	;; start
000000r 1               	;; in 816 mode, allowing interrupts, expect fun and games
000000r 1               	;; in 816 mode, still alive
000000r 1               	;; aaa
000000r 1               	;; back in 6502 mode, done
000000r 1               	;;
000000r 1               	;;
000000r 1               	;;
000000r 1               
000000r 1               
000000r 1                       .setcpu "65816"
000000r 1               	.listbytes      unlimited
000000r 1               	.code
000000r 1               
000000r 1               	;; .DEFINE OSASCI  $FFE3   ; commented out so I can overload it>
000000r 1                       .DEFINE OSBYTE  $FFF4
000000r 1                       .DEFINE OSWRCH  $FFEE
000000r 1                       .DEFINE OSRDCH  $FFE0
000000r 1               
000000r 1                       .MACRO MAC_MODE816
000000r 1                       SEI                     ; disable interrupts and enter 816 mode
000000r 1                       CLC
000000r 1                       XCE
000000r 1               	.A8
000000r 1               	.I8
000000r 1               	SEP #$30		; force 8-bit for A and M bits
000000r 1                       .ENDMACRO
000000r 1               
000000r 1                       .MACRO MAC_MODE02
000000r 1                       SEC                     ; enter emulation mode and reenable interrupts
000000r 1                       XCE
000000r 1                       NOP			;  NOP for safety as we switch back
000000r 1                       NOP			;  NOP for safety as we switch back
000000r 1                       NOP			;  NOP for safety as we switch back
000000r 1                       NOP			;  NOP for safety as we switch back
000000r 1               	CLI
000000r 1                       .ENDMACRO
000000r 1               
000000r 1               	.MACRO MAC_PUTS string
000000r 1               	JSR PRNTSTR
000000r 1               	.BYTE $0d,string,$0d
000000r 1               	NOP
000000r 1               	.ENDMACRO
000000r 1               
000000r 1               	.MACRO MAC_PUTC_NOINT char
000000r 1               	PHP
000000r 1               	PHA
000000r 1               	LDA &0250 		;  OS shadow of ACIA control register ($96 = %10010110)
000000r 1               	;; work in progress
000000r 1               	LDA #char
000000r 1               	JSR OSASCI
000000r 1               	PLA
000000r 1               	PLP
000000r 1               	.ENDMACRO
000000r 1               
000000r 1               	.MACRO MAC_PUTC char	;
000000r 1               	PHP			; preserve the flags
000000r 1               	PHA
000000r 1               	LDA #char
000000r 1               	JSR OSASCI
000000r 1               	PLA
000000r 1               	PLP
000000r 1               	.ENDMACRO
000000r 1               
000000r 1               .define  irqvector816  $FFEE
000000r 1               .define  irqvector02   $FFFE
000000r 1               
000000r 1               .ORG $4000
004000  1               testprog:	;;
004000  1  4C 0F 40     	JMP testprog_more
004003  1               
004003  1               irqcounter:	;; PRINT ~!&2003
004003  1  00 00 00 00  	.BYTE $0,$0,$0,$0
004007  1               
004007  1               loopcounter:	;; PRINT ~!&2007
004007  1  00 00 03 00  	.BYTE $0,$0,$3,$0	;  about a second
00400B  1               
00400B  1               irqstacks:	;; PRINT ~!&200B
00400B  1  00 00 00 00  	.BYTE $0,$0,$0,$0	;
00400F  1               
00400F  1               testprog_more:	;;
00400F  1  20 2A 41 0D  	MAC_PUTS "start"
004013  1  73 74 61 72  
004017  1  74 0D EA     
00401A  1  78 18 FB E2  	MAC_MODE816
00401E  1  30           
00401F  1               
00401F  1  A9 4C        	LDA #$4C			; save a JMP at 0E6C - OS1.20 sends 816-IRQ there
004021  1  8D 6C 0E     	STA $E6C
004024  1  A9 09        	LDA # .lobyte(irqhandler816)
004026  1  8F EE FF FE  	STA $FE0000 + irqvector816
00402A  1  8D 6D 0E     	STA $E6D
00402D  1  A9 41        	LDA # .hibyte(irqhandler816)
00402F  1  8F EF FF FE  	STA $FE0000 + irqvector816 + 1
004033  1  8D 6E 0E     	STA $E6E
004036  1               
004036  1  20 2A 41 0D  	MAC_PUTS "in 816 mode, allowing interrupts, expect fun and games"
00403A  1  69 6E 20 38  
00403E  1  31 36 20 6D  
004042  1  6F 64 65 2C  
004046  1  20 61 6C 6C  
00404A  1  6F 77 69 6E  
00404E  1  67 20 69 6E  
004052  1  74 65 72 72  
004056  1  75 70 74 73  
00405A  1  2C 20 65 78  
00405E  1  70 65 63 74  
004062  1  20 66 75 6E  
004066  1  20 61 6E 64  
00406A  1  20 67 61 6D  
00406E  1  65 73 0D EA  
004072  1  58            	CLI
004073  1  20 2A 41 0D  	MAC_PUTS "in 816 mode, still alive"
004077  1  69 6E 20 38  
00407B  1  31 36 20 6D  
00407F  1  6F 64 65 2C  
004083  1  20 73 74 69  
004087  1  6C 6C 20 61  
00408B  1  6C 69 76 65  
00408F  1  0D EA        
004091  1  EA           	NOP
004092  1               tightloop:
004092  1  EA           	NOP
004093  1  EA           	NOP
004094  1  CE 07 40     	DEC loopcounter
004097  1  D0 F9        	BNE tightloop
004099  1  CE 08 40     	DEC loopcounter	+ 1
00409C  1  D0 F4        	BNE tightloop
00409E  1  08 48 A9 61  	MAC_PUTC 'a'
0040A2  1  20 4A 41 68  
0040A6  1  28           
0040A7  1  CE 09 40     	DEC loopcounter	+ 2
0040AA  1  D0 E6        	BNE tightloop
0040AC  1  38 FB EA EA  	MAC_MODE02
0040B0  1  EA EA 58     
0040B3  1               
0040B3  1  20 2A 41 0D  	MAC_PUTS "back in 6502 mode, done"
0040B7  1  62 61 63 6B  
0040BB  1  20 69 6E 20  
0040BF  1  36 35 30 32  
0040C3  1  20 6D 6F 64  
0040C7  1  65 2C 20 64  
0040CB  1  6F 6E 65 0D  
0040CF  1  EA           
0040D0  1               
0040D0  1  60           	RTS
0040D1  1               
0040D1  1               
0040D1  1               irqhandler816x:
0040D1  1               	;; a trivial handler. It can't clear the irq source
0040D1  1               	;; so it has to disable interrupts in order not to be
0040D1  1               	;; invoked endlessly.  (Disable them in the saved flags register)
0040D1  1               	;; (the P as we enter the handler has SEI already)
0040D1  1  48           	PHA
0040D2  1  DA           	PHX
0040D3  1  EE 03 40     	INC irqcounter ; we want to leave a record
0040D6  1  BA           	TSX
0040D7  1  BD 03 01     	LDA $0103,X		; PLP would be wrong - would re-enable interrupts!
0040DA  1  09 04        	ORA #%00000100		;  make this a one-shot by setting saved SEI bit. status flags are nvmxdizc
0040DC  1  9D 03 01     	STA $0103,X		; again, PHP would be wrong, as the B bit is not real in P
0040DF  1               	;; place a sentinel and take a copy of the stack
0040DF  1               takecopy:
0040DF  1  BA           	TSX
0040E0  1  8A           	TXA
0040E1  1  48           	PHA			; stack pointer
0040E2  1  A9 ED        	LDA #$ED
0040E4  1  48           	PHA			; sentinel 1
0040E5  1  48           	PHA			; sentinel 2
0040E6  1  68           	PLA			; sentinel 2
0040E7  1  68           	PLA			; sentinel 1
0040E8  1  68           	PLA			; stack pointer
0040E9  1               
0040E9  1  A2 FF         	LDX #$FF
0040EB  1  AD 03 40     	LDA irqcounter
0040EE  1  C9 01        	CMP #1
0040F0  1  D0 0C        	BNE stackcopy3
0040F2  1               stackcopy2:
0040F2  1  BD 00 01     	LDA $0100,X
0040F5  1  9D 00 24     	STA $2400,X
0040F8  1  CA           	DEX
0040F9  1  D0 F7        	BNE stackcopy2
0040FB  1               stackrestore:
0040FB  1  FA           	PLX			; x
0040FC  1  68           	PLA			; a
0040FD  1  40           	RTI
0040FE  1               stackcopy3:
0040FE  1  BD 00 01     	LDA $0100,X
004101  1  9D 00 26     	STA $2600,X
004104  1  CA           	DEX
004105  1  D0 F7        	BNE stackcopy3
004107  1  F0 F2        	BEQ stackrestore
004109  1               
004109  1               irqhandler816:
004109  1               	;; irq handling code derived from http://cerebro.xu.edu/~ryanr/atari/65816.html
004109  1               	;; this is called from the 816 irq vector, so only called in 816 mode
004109  1               	;; a beeb-hosted 816 must switch to 6502 mode to use the OS handler
004109  1               	;; or it could handle it itself
004109  1               	;; note that the machine will already have pushed P and done SEI
004109  1  0B                   PHD    		; Save DBR and Direct
00410A  1  8B                   PHB
00410B  1  F4 00 00             PEA $0000     	; Clear Direct...
00410E  1  2B                   PLD           	;
00410F  1  4B           	PHK		; ... and with a single zero byte ...
004110  1  AB                   PLB		; ... clear the DBR
004111  1  DA                   PHX           	; X&Y saved at present width, because resetting them
004112  1  5A                   PHY           	;  to 8 bits would destroy the upper half contents.
004113  1  08           	PHP  		; push 816 P reg for reg width info (I was set as IRQ vector fetched)
004114  1               
004114  1               	;; push a fake interrupt frame so we can call the 6502 host interrupt service
004114  1  62 0B 00     	PER IRETURN   	; push return address (then status) for the RTI
004117  1  E2 30        	SEP #%00110000 	; Set 8 bit regs
004119  1  A9 04        	LDA #%00000100  ; we want I set and B clear for the 6502 irq handler
00411B  1  48           	PHA           	; saving for sake of 6502 handler and RTI
00411C  1               
00411C  1               	;; everything is safe
00411C  1               	;; switch to 6502 mode for the host interrupt service routine
00411C  1  38           	SEC
00411D  1  FB           	XCE
00411E  1  EA           	NOP		; residual doubt about our clock switching?
00411F  1               
00411F  1               	;;        now jump to the appropriate interrupt vector, such as...
00411F  1  6C FE FF     	JMP (irqvector02) ; Its RTI will return to IRETURN
004122  1               
004122  1               IRETURN:
004122  1  18           	CLC		; beeb special:	return to 816-mode (we're in the 816-mode handler!)
004123  1  FB           	XCE
004124  1  28           	PLP 		; recover unmodified 816 status byte - for reg widths
004125  1               			;  we know this saved P has SEI
004125  1               	                ; we don't worry about N and Z because the next RTI will pull a real P
004125  1  7A           	PLY           	;  now restore X&Y at whatever width they were saved at
004126  1  FA                   PLX           	;
004127  1  AB                   PLB           	; Restore DBR and Direct
004128  1  2B                   PLD
004129  1  40                   RTI           	; Return to main program (pulling genuine user-mode P then 3 PC bytes)
00412A  1               
00412A  1               
00412A  1               	;; notes on the beeb's irq handling:
00412A  1               	;; FFFE  6502-mode irq vector = DC1C
00412A  1               	;; DC1C  save A in &FC; check PLP for B bit
00412A  1               	;; DC27  BRK-handler
00412A  1               	;; (0204)  IRQ1V = DC93 - pre-handler for highest priority interception
00412A  1               	;; DC93  start checking ACIA status
00412A  1               	;; check all other expected hardware sources
00412A  1               	;; (0206)  IRQ2V = DE89 - post-handler for unhandled sources
00412A  1               
00412A  1               	;; ----------------------------------------------------------------------
00412A  1                       ;; Print inline text up to NOP
00412A  1                       ;; ----------------------------------------------------------------------
00412A  1               PRNTSTR:
00412A  1  68                   PLA
00412B  1  85 F6                STA $F6
00412D  1  68                   PLA
00412E  1  85 F7                STA $F7                 ;Pop return address to &F6/7
004130  1  98                   TYA
004131  1  48                   PHA
004132  1  A0 00                LDY #$00
004134  1  F0 03                BEQ PRNTSTRBGN
004136  1               PRNTSTRNXT:
004136  1  20 4A 41             JSR OSASCI
004139  1               PRNTSTRBGN:
004139  1  E6 F6                INC $F6
00413B  1  D0 02                BNE PRNTSTRSKP
00413D  1  E6 F7                INC $F7                 ; Increment address
00413F  1               PRNTSTRSKP:
00413F  1  B1 F6                LDA ($F6),Y             ; Get character
004141  1  C9 EA                CMP #$EA
004143  1  D0 F1                BNE PRNTSTRNXT          ; If not 'NOP' opcode, loop to print it
004145  1  68                   PLA
004146  1  A8                   TAY
004147  1  6C F6 00             JMP ($00F6)             ; Pop Y and jump back to code
00414A  1               
00414A  1               
00414A  1               OSASCI:				; polling-mode serial putc, needs no OS or interrupts
00414A  1  C9 0D        	CMP #$0D
00414C  1  D0 07        	BNE OSASCI_PUTC
00414E  1  A9 0A        	LDA #$0A
004150  1  20 55 41     	JSR OSASCI_PUTC
004153  1  A9 0D        	LDA #$0D
004155  1               OSASCI_PUTC:
004155  1  48           	PHA
004156  1               OSASCI_BUSY:
004156  1  A9 02        	LDA #2
004158  1  2D 08 FE     	AND $FE08
00415B  1  F0 F9        	BEQ OSASCI_BUSY
00415D  1  68           	PLA
00415E  1  8D 09 FE     	STA $FE09
004161  1  60           	RTS
004162  1               
004162  1               
