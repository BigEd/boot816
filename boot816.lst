ca65 V2.13.2 - (C) Copyright 1998-2005 Ullrich von Bassewitz
Main file   : boot816.as
Current file: boot816.as

000000r 1                       ;; ---------------------------------------------------------
000000r 1                       ;;
000000r 1                       ;; Boot816
000000r 1                       ;;
000000r 1                       ;; Boot ROM based on Ed's code to detect CPU type and
000000r 1                       ;; redirect IO to the serial port on startup. Added
000000r 1                       ;; new * extension commands for testing various
000000r 1                       ;; 65816 configurations.
000000r 1                       ;;
000000r 1                       ;; ---------------------------------------------------------
000000r 1                       ;; (C) 2008-2010 Ed Spittles, Richard Evans
000000r 1                       ;; ---------------------------------------------------------
000000r 1                       ;;
000000r 1                       ;; $Author:$
000000r 1                       ;; $Id:$
000000r 1                       ;; $Rev: 381 $
000000r 1                       ;;
000000r 1                       .SETCPU "65816"
000000r 1                       .ORG $8000
008000  1               
008000  1                       .DEFINE ROMLATCH	$FE30
008000  1                       .DEFINE ROMLATCHCOPY	  $F4
008000  1               
008000  1               	.DEFINE OSRDRM  $FFB9 rom number in Y, address in &F6/7, X and Y not preserved
008000  1                       .DEFINE GSINIT  $FFC2
008000  1                       .DEFINE GSREAD  $FFC5
008000  1                       .DEFINE OSASCI  $FFE3
008000  1                       .DEFINE OSNEWL  $FFE7
008000  1                       .DEFINE OSWRCH  $FFEE
008000  1                       .DEFINE OSRDCH  $FFE0
008000  1                       .DEFINE OSWORD  $FFF1
008000  1                       .DEFINE OSBYTE  $FFF4
008000  1               
008000  1                       ;; zero page usage:
008000  1               	;; &70 - &8F - unused by OS, granted to user by BASIC
008000  1                       ;;           - up to 4 bytes will be used by hipeek and hipoke
008000  1                       ;; &A8-&AF   - free for 'os commands' - might be overwritten by OSASCI used by prntstr?
008000  1                 	;; &B0-&CF   - available to a ROM, but it is supposed to claim and release it
008000  1                       ;; &F2, &F3  - official OS text pointer (our command line, also used for gsinit/gsread)
008000  1                       ;; &F6, &F7  - officially ptr into paged ROM, used here by mem testers and prntstr
008000  1               
008000  1                       .MACRO MAC_MODE816
008000  1                       SEI                     ; disable interrupts and enter 816 mode
008000  1                       CLC
008000  1                       XCE
008000  1                       .ENDMACRO
008000  1               
008000  1                       .MACRO MAC_MODE02
008000  1                       SEC                     ; enter emulation mode and reenable interrupts
008000  1                       XCE
008000  1                       NOP                     ; delay before re-enabling interrupts
008000  1                       NOP
008000  1                       CLI
008000  1                       .ENDMACRO
008000  1               
008000  1               	.MACRO MAC_SWAP	AA, BB ;  there's a clever way with XOR...
008000  1                       LDA AA
008000  1               	XBA
008000  1                       LDA BB
008000  1               	STA AA
008000  1               	XBA
008000  1                       STA BB
008000  1               	.ENDMACRO
008000  1               
008000  1               
008000  1  00 00 00     LANG:   .BYTE $00,$00,$00       ; no language entry
008003  1  4C 48 80     SERV:   JMP CHECK               ; service entry
008006  1  82           TYPE:   .BYTE $82               ; ROM type=Serv+6502
008007  1  29           OFST:   .BYTE COPYRT-LANG
008008  1  02           VERNO:  .BYTE $02
008009  1  42 4F 4F 54  TITLE:  .BYTE "BOOT816 - 65816 support",$0D
00800D  1  38 31 36 20  
008011  1  2D 20 36 35  
008021  1  00                   .BYTE $00
008022  1  32 30 30 38  TITLE2: .BYTE "2008-10"
008026  1  2D 31 30     
008029  1  00           COPYRT: .BYTE $00
00802A  1  28 43 29 20          .BYTE "(C) Rich Evans & Ed Spittles",$0D
00802E  1  52 69 63 68  
008032  1  20 45 76 61  
008047  1  00                   .BYTE $00
008048  1  C9 04        CHECK:  CMP #$04                ; is it a command?
00804A  1  D0 03                BNE HPCH                ; ..no, is it help?
00804C  1  4C A7 81             JMP COMCH               ; ..yes, check command list
00804F  1  C9 09        HPCH:   CMP #$09                ; is it a help rqst?
008051  1  D0 03                BNE SRVCCH              ; ..no, is it service rqst?
008053  1  4C 65 80             JMP HLPCH               ; ..yes, check if for this ROM
008056  1  C9 03        SRVCCH: CMP #$03                ; is it a service3 ?
008058  1  D0 03                BNE SRVC27CH            ; ..no, is it srvc27?
00805A  1  4C 16 86             JMP Service3Reset       ; ..yes, handle a service 3
00805D  1  C9 27        SRVC27CH: CMP #$27              ; is it a service27?
00805F  1  D0 03                BNE OUT                 ; ..no, bug out
008061  1  4C 1C 86             JMP Service27Reset      ; ..yes
008064  1  60           OUT:    RTS
008065  1  08           HLPCH:  PHP                     ; save registers
008066  1  48                   PHA
008067  1  8A                   TXA
008068  1  48                   PHA
008069  1  98                   TYA
00806A  1  48                   PHA
00806B  1  A2 00                LDX #$00
00806D  1                       ;; Y as passed to us is part of the pointer
00806D  1  B1 F2        BLOOP:  LDA ($F2),Y
00806F  1  DD 09 80             CMP TITLE,X             ; check request against
008072  1  F0 08                BEQ NXLET               ; title, cater for lower
008074  1  38                   SEC                     ; case letters
008075  1  E9 20                SBC #$20
008077  1  DD 09 80             CMP TITLE,X
00807A  1  D0 1C                BNE SMALL               ; not this ROM, print
00807C  1  E8           NXLET:  INX                     ; name only
00807D  1  C8                   INY
00807E  1  B1 F2                LDA ($F2),Y
008080  1  C9 2E                CMP #$2E                ; Cater for abbreviations
008082  1  F0 04                BEQ LARGE
008084  1  E0 05                CPX #$05
008086  1  90 E5                BCC BLOOP
008088  1  A2 00        LARGE:  LDX #$00
00808A  1  BD B8 80     LLOOP:  LDA BTEXT,X             ; Print full help
00808D  1  C9 00                CMP #$00
00808F  1  F0 17                BEQ BOUT
008091  1  20 E3 FF             JSR OSASCI
008094  1  E8                   INX
008095  1  4C 8A 80             JMP LLOOP
008098  1  A2 00        SMALL:  LDX #$00
00809A  1  BD 84 81     SLOOP:  LDA LTEXT,X             ; print small help
00809D  1  C9 00                CMP #$00
00809F  1  F0 10                BEQ LOUT
0080A1  1  20 E3 FF             JSR OSASCI
0080A4  1  E8                   INX
0080A5  1  4C 9A 80             JMP SLOOP
0080A8  1  68           BOUT:   PLA
0080A9  1  A8                   TAY
0080AA  1  68                   PLA
0080AB  1  AA                   TAX
0080AC  1  68                   PLA
0080AD  1  28                   PLP
0080AE  1  A9 00                LDA #$00                ; prevent other ROMs responding by setting a 0
0080B0  1  60                   RTS
0080B1  1  68           LOUT:   PLA
0080B2  1  A8                   TAY
0080B3  1  68                   PLA
0080B4  1  AA                   TAX
0080B5  1  68                   PLA
0080B6  1  28                   PLP
0080B7  1  60                   RTS                     ; offer help rqst to other roms by not altering A
0080B8  1  0D           BTEXT:  .BYTE $0D
0080B9  1  42 4F 4F 54          .BYTE "BOOT816 ROM - new * commands",$0D
0080BD  1  38 31 36 20  
0080C1  1  52 4F 4D 20  
0080D6  1  20 20 42 49          .BYTE "  BIST20",$0D
0080DA  1  53 54 32 30  
0080DE  1  0D           
0080DF  1  20 20 48 49          .BYTE "  HITESTHIMEM",$0D
0080E3  1  54 45 53 54  
0080E7  1  48 49 4D 45  
0080ED  1  20 20 52 45          .BYTE "  REPORTCPU",$0D
0080F1  1  50 4F 52 54  
0080F5  1  43 50 55 0D  
0080F9  1  20 20 52 45          .BYTE "  REPORTHIMEM",$0D
0080FD  1  50 4F 52 54  
008101  1  48 49 4D 45  
008107  1  20 20 53 45          .BYTE "  SETSERIALREDIRECT",$0D
00810B  1  54 53 45 52  
00810F  1  49 41 4C 52  
00811B  1               .ifdef SRECORD_D
00811B  1  20 20 53 52          .BYTE "  SRECORD", $0D
00811F  1  45 43 4F 52  
008123  1  44 0D        
008125  1               .endif
008125  1  20 20 54 45          .BYTE "  TEST816",$0D
008129  1  53 54 38 31  
00812D  1  36 0D        
00812F  1  20 20 54 45          .BYTE "  TESTHIMEM",$0D
008133  1  53 54 48 49  
008137  1  4D 45 4D 0D  
00813B  1               .ifdef IRQINSTALL_D
00813B  1                       .BYTE "  IRQINSTALL",$0D
00813B  1               .endif
00813B  1  20 20 48 49          .BYTE "  HIPEEK",$0D
00813F  1  50 45 45 4B  
008143  1  0D           
008144  1  20 20 48 49          .BYTE "  HIPOKE",$0D
008148  1  50 4F 4B 45  
00814C  1  0D           
00814D  1  20 20 48 45          .BYTE "  HEXDUMP",$0D
008151  1  58 44 55 4D  
008155  1  50 0D        
008157  1  20 20 4F 56          .BYTE "  OVERLAYON",$0D
00815B  1  45 52 4C 41  
00815F  1  59 4F 4E 0D  
008163  1  20 20 4F 56          .BYTE "  OVERLAYOFF",$0D
008167  1  45 52 4C 41  
00816B  1  59 4F 46 46  
008170  1  20 20 4D 45          .BYTE "  MEMCOPY",$0D
008174  1  4D 43 4F 50  
008178  1  59 0D        
00817A  1  20 20 4F 53          .BYTE "  OSCOPY",$0D
00817E  1  43 4F 50 59  
008182  1  0D           
008183  1  00                   .BYTE $00
008184  1  0D           LTEXT:  .BYTE $0D
008185  1  42 4F 4F 54          .BYTE "BOOT816 $Rev: 381 $",$0D
008189  1  38 31 36 20  
00818D  1  24 52 65 76  
008199  1  00                   .BYTE $00
00819A  1  BD F5 81     LOCHK:  LDA COMLIST,X           ; routine to cater for lower case letters
00819D  1  18                   CLC
00819E  1  69 20                ADC #$20
0081A0  1  D1 F2                CMP ($F2),Y
0081A2  1  F0 11                BEQ CLOOP
0081A4  1  4C C3 81             JMP BACKUP
0081A7  1  48           COMCH:  PHA                     ; COMMAND CHECK
0081A8  1  8A                   TXA
0081A9  1  48                   PHA
0081AA  1  98                   TYA
0081AB  1  48                   PHA
0081AC  1  8C 02 0A             STY $0A02               ; SAVE Y OFFSET
0081AF  1  A2 FF                LDX #$FF
0081B1  1  AC 02 0A     GRABY:  LDY $0A02
0081B4  1  88                   DEY
0081B5  1  C8           CLOOP:  INY
0081B6  1  E8                   INX
0081B7  1  BD F5 81             LDA COMLIST,X           ; check command list
0081BA  1  30 1B                BMI NEG                 ; is it an address?
0081BC  1  D1 F2                CMP ($F2),Y
0081BE  1  D0 DA                BNE LOCHK               ; is it lower case
0081C0  1  4C B5 81             JMP CLOOP
0081C3  1  E8           BACKUP: INX
0081C4  1  BD F5 81             LDA COMLIST,X
0081C7  1  10 FA                BPL BACKUP
0081C9  1  E8                   INX
0081CA  1  B1 F2                LDA ($F2),Y
0081CC  1  C9 2E                CMP #$2E                ; cater for abbreviations
0081CE  1  D0 E1                BNE GRABY
0081D0  1  C8                   INY
0081D1  1  CA                   DEX
0081D2  1  BD F5 81             LDA COMLIST,X
0081D5  1  D0 04                BNE GRABADD
0081D7  1  C9 FF        NEG:    CMP #$FF                ; bottom of command list
0081D9  1  F0 0D                BEQ BYE                 ; yes, so exit
0081DB  1  8D 01 0A     GRABADD: STA $0A01
0081DE  1  BD F6 81             LDA COMLIST+1,X         ; ELSE LOAD ADDRESS
0081E1  1  8D 00 0A             STA $0A00
0081E4  1  20 F2 81             JSR EXEC                ; and goto command code
0081E7  1  18                   CLC
0081E8  1  68           BYE:    PLA
0081E9  1  A8                   TAY
0081EA  1  68                   PLA
0081EB  1  AA                   TAX
0081EC  1  68                   PLA
0081ED  1  B0 02                BCS HOP                 ; if command performed then
0081EF  1  A9 00                LDA #$00                ; stop other ROMS responding
0081F1  1  60           HOP:    RTS
0081F2  1  6C 00 0A     EXEC:   JMP ($0A00)
0081F5  1                       ;; Table of command names and jump targets
0081F5  1               COMLIST:
0081F5  1  42 49 53 54          .BYTE "BIST20"
0081F9  1  32 30        
0081FB  1  86                   .BYTE >BIST20
0081FC  1  30                   .BYTE <BIST20
0081FD  1               .ifdef IRQINSTALL_D
0081FD  1                       .BYTE "IRQINSTALL"
0081FD  1                       .BYTE >IRQINSTALL
0081FD  1                       .BYTE <IRQINSTALL
0081FD  1               .endif
0081FD  1  48 49 54 45          .BYTE "HITESTHIMEM"
008201  1  53 54 48 49  
008205  1  4D 45 4D     
008208  1  84                   .BYTE >HITESTHIMEM
008209  1  33                   .BYTE <HITESTHIMEM
00820A  1  52 45 50 4F          .BYTE "REPORTCPU"
00820E  1  52 54 43 50  
008212  1  55           
008213  1  85                   .BYTE >REPORTCPU
008214  1  37                   .BYTE <REPORTCPU
008215  1  52 45 50 4F          .BYTE "REPORTHIMEM"
008219  1  52 54 48 49  
00821D  1  4D 45 4D     
008220  1  82                   .BYTE >REPORTHIMEM
008221  1  A8                   .BYTE <REPORTHIMEM
008222  1  53 45 54 53          .BYTE "SETSERIALREDIRECT"
008226  1  45 52 49 41  
00822A  1  4C 52 45 44  
008233  1  85                   .BYTE >SetSerialRedirect
008234  1  D2                   .BYTE <SetSerialRedirect
008235  1               .ifdef SRECORD_D
008235  1  53 52 45 43          .BYTE "SRECORD"
008239  1  4F 52 44     
00823C  1  88                   .BYTE >SRECORD
00823D  1  EE                   .BYTE <SRECORD
00823E  1               .endif
00823E  1  54 45 53 54          .BYTE "TEST816"
008242  1  38 31 36     
008245  1  82                   .BYTE >TST816
008246  1  94                   .BYTE <TST816
008247  1  54 45 53 54          .BYTE "TESTHIMEM"
00824B  1  48 49 4D 45  
00824F  1  4D           
008250  1  82                   .BYTE >TESTHIMEM
008251  1  EC                   .BYTE <TESTHIMEM
008252  1  48 45 58 44          .BYTE "HEXDUMP"
008256  1  55 4D 50     
008259  1  87                   .BYTE >HEXDUMP
00825A  1  A2                   .BYTE <HEXDUMP
00825B  1  48 49 50 45          .BYTE "HIPEEK"
00825F  1  45 4B        
008261  1  87                   .BYTE >HIPEEK
008262  1  42                   .BYTE <HIPEEK
008263  1  48 49 50 4F          .BYTE "HIPOKE"
008267  1  4B 45        
008269  1  87                   .BYTE >HIPOKE
00826A  1  5E                   .BYTE <HIPOKE
00826B  1  4F 56 45 52          .BYTE "OVERLAYON"
00826F  1  4C 41 59 4F  
008273  1  4E           
008274  1  86                   .BYTE >OVERLAYON
008275  1  3E                   .BYTE <OVERLAYON
008276  1  4F 56 45 52          .BYTE "OVERLAYOFF"
00827A  1  4C 41 59 4F  
00827E  1  46 46        
008280  1  86                   .BYTE >OVERLAYOFF
008281  1  75                   .BYTE <OVERLAYOFF
008282  1  4D 45 4D 43          .BYTE "MEMCOPY"
008286  1  4F 50 59     
008289  1  86                   .BYTE >MEMCOPY
00828A  1  AC                   .BYTE <MEMCOPY
00828B  1  4F 53 43 4F          .BYTE "OSCOPY"
00828F  1  50 59        
008291  1  86                   .BYTE >OSCOPY
008292  1  D5                   .BYTE <OSCOPY
008293  1  FF                   .BYTE $FF
008294  1                       ;; ------------------------------------------------------------------------
008294  1                       ;; (*)TEST816
008294  1                       ;;
008294  1                       ;; Skip into and back out of out of 816 native mode after first
008294  1                       ;; detecting that the 65816 is present.
008294  1                       ;; ------------------------------------------------------------------------
008294  1               
008294  1               TST816:
008294  1  20 D2 82             JSR DieIfNot65816
008297  1  78 18 FB             MAC_MODE816
00829A  1  C2 10                REP #%00010000          ; enable 16b index registers!
00829C  1  E2 10                SEP #%00010000          ; disable 16b index registers!
00829E  1  38 FB EA EA          MAC_MODE02
0082A2  1  58           
0082A3  1  A0 00                LDY #00
0082A5  1  4C 51 83             JMP ReportResult
0082A8  1                       ; done
0082A8  1               
0082A8  1                       ;; ------------------------------------------------------------------------
0082A8  1                       ;; REPORTHIMEM (*REPORTHIMEM)
0082A8  1                       ;;
0082A8  1                       ;; Detect HIMEM by writing and retrieving a single data byte and checking
0082A8  1                       ;; that the operation is not aliased to a location in the normal memory map
0082A8  1                       ;;
0082A8  1                       ;;
0082A8  1                       ;; Checks that an '816 is fitted before attempting to check himem but
0082A8  1                       ;; don't need to go into native mode for the test.
0082A8  1                       ;; ------------------------------------------------------------------------
0082A8  1               
0082A8  1               
0082A8  1               REPORTHIMEM:
0082A8  1  20 D2 82             JSR DieIfNot65816
0082AB  1  20 B1 82             JSR DetectHiMem         ; result returned in Y
0082AE  1  4C 51 83             JMP ReportResult        ; Use Y value to report result
0082B1  1                       ; done
0082B1  1               
0082B1  1               DetectHiMem:
0082B1  1  A9 AA                LDA #$AA                ; Store checkerboard to aliased location
0082B3  1  85 F6                STA $F6
0082B5  1  A9 55                LDA #$55
0082B7  1  8F F6 00 FF          STA $FF00F6             ; Store inverted checkerboard to himem
0082BB  1  A5 F6                LDA $F6                 ; retrieve checkerboard from lo mem
0082BD  1  C9 AA                CMP #$AA                ; compare with expected value
0082BF  1  F0 03                BEQ DETNXT1             ; ..skip fail code if it's ok
0082C1  1  A0 02                LDY #02                 ; return fail code 2 : aliassing
0082C3  1  60                   RTS
0082C4  1  AF F6 00 FF  DETNXT1: LDA $FF00F6            ; retrieve inverted checkerboard from hi mem
0082C8  1  C9 55                CMP #$55                ; compare with expected value
0082CA  1  F0 03                BEQ DETNXT2             ; ..skip fail code it it's ok
0082CC  1  A0 01                LDY #01                 ; return fail code 1 : mismatch
0082CE  1  60                   RTS
0082CF  1  A0 00        DETNXT2:LDY #00                 ; return code 0 : pass
0082D1  1               DieReturnsOK:
0082D1  1  60                   RTS
0082D2  1               
0082D2  1               DieIfNot65816:
0082D2  1  20 B0 85             JSR DetectCPUType
0082D5  1  C9 03                CMP #$03
0082D7  1  F0 F8                BEQ DieReturnsOK
0082D9  1  68                   PLA          ; discard the return address
0082DA  1  68                   PLA
0082DB  1  A0 03                LDY #$03
0082DD  1  4C 51 83             JMP ReportResult
0082E0  1                       ; done
0082E0  1               
0082E0  1               DieIfNoHiMem:
0082E0  1  20 B1 82             JSR DetectHiMem
0082E3  1  C0 00                CPY #$00
0082E5  1  F0 EA                BEQ DieReturnsOK
0082E7  1  68                   PLA                    ; discard our caller's return address
0082E8  1  68                   PLA
0082E9  1  4C 42 88             JMP MSG_NOHIMEM
0082EC  1                       ; done
0082EC  1               
0082EC  1               
0082EC  1                       ;; ----------------------------------------------------------------------
0082EC  1                       ;; TESTHIMEM (*TESTHIMEM)
0082EC  1                       ;;
0082EC  1                       ;; Very simple test of a 64K byte area of HIMEM.
0082EC  1                       ;;
0082EC  1                       ;; Fill the area with one pattern, then read it back and compare it.
0082EC  1                       ;; Repeat with the inverted version of the pattern
0082EC  1                       ;;
0082EC  1                       ;; Temporarily disables interrupts to switch to 816 mode but returns with
0082EC  1                       ;; the CPU back in emulation mode and interrupts enabled
0082EC  1                       ;;
0082EC  1                       ;; Uses location $F6 of page zero for temporary storage
0082EC  1                       ;;
0082EC  1                       ;; Uses the X index register in 16bit mode to point to addresses during
0082EC  1                       ;; the test.
0082EC  1                       ;;
0082EC  1                       ;; Need to detect presence of 816 CPU first, and then presence of HIMEM
0082EC  1                       ;; before running the test. ie Don't crash a BBC or a BBC with a L0 '816
0082EC  1                       ;; board when running this command.
0082EC  1                       ;;
0082EC  1                       ;; ----------------------------------------------------------------------
0082EC  1               TESTHIMEM:
0082EC  1                       .DEFINE         MEMTOP          $FFFF
0082EC  1                       .DEFINE         MEMBOT          $0000
0082EC  1                       .DEFINE         MEMTESTAREA     $FF0000
0082EC  1                       .DEFINE         PZ_BKG0         $F6
0082EC  1                       .DEFINE         PZ_BKG1         PZ_BKG0 + 1
0082EC  1                       .DEFINE         HIMARCHSTART    $FE5000
0082EC  1                       .DEFINE         HI_WrDown       HIMARCHSTART + WrDown - MARCHSTART
0082EC  1                       .DEFINE         HI_RdWrUp       HIMARCHSTART + RdWrUp - MARCHSTART
0082EC  1                       .DEFINE         HI_RdWrDown     HIMARCHSTART + RdWrDown - MARCHSTART
0082EC  1                       .DEFINE         CODESIZE        MARCHEND-MARCHSTART
0082EC  1               
0082EC  1                       ;; Check 65816 is fitted first
0082EC  1  20 D2 82             JSR DieIfNot65816
0082EF  1               
0082EF  1                       ;; Check HiMem is fitted next before testing it
0082EF  1  20 E0 82             JSR DieIfNoHiMem
0082F2  1               
0082F2  1  20 17 85             JSR PRNTSTR
0082F5  1  0D 4D 61 72          .BYTE $0D,"March0: >wr(0)      .."
0082F9  1  63 68 30 3A  
0082FD  1  20 3E 77 72  
00830C  1  EA                   NOP
00830D  1               
00830D  1  A9 55                LDA #$55
00830F  1  78 18 FB             MAC_MODE816  ; will use 16-bit index mode (but the JSL should be fine)
008312  1  22 1E 84 00          JSL WrDown
008316  1  38 FB EA EA          MAC_MODE02
00831A  1  58           
00831B  1               
00831B  1  20 BA 84             JSR PrintDoneandAnnounceMarch1
00831E  1               
00831E  1  A9 55                LDA #$55
008320  1  78 18 FB             MAC_MODE816
008323  1  22 CE 83 00          JSL RdWrDown
008327  1  38 FB EA EA          MAC_MODE02
00832B  1  58           
00832C  1               
00832C  1  20 DB 84             JSR ReportAndAnnounceMarch2   ; result is in Y
00832F  1               
00832F  1  A9 AA                LDA #$AA
008331  1  78 18 FB             MAC_MODE816
008334  1  22 F6 83 00          JSL RdWrUp
008338  1  38 FB EA EA          MAC_MODE02
00833C  1  58           
00833D  1               
00833D  1  20 F9 84             JSR ReportAndAnnounceMarch3   ; result is in Y
008340  1               
008340  1  A9 55                LDA #$55
008342  1  78 18 FB             MAC_MODE816
008345  1  22 F6 83 00          JSL RdWrUp
008349  1  38 FB EA EA          MAC_MODE02
00834D  1  58           
00834E  1  4C 51 83             JMP ReportResult        ; result is in Y
008351  1                       ; done
008351  1               
008351  1               ReportResult:
008351  1  C0 04                CPY #04
008353  1  D0 0B                BNE Report03
008355  1  20 17 85             JSR PRNTSTR
008358  1  20 46 61 69          .BYTE " Fail",$0D
00835C  1  6C 0D        
00835E  1  EA                   NOP
00835F  1  60                   RTS
008360  1               Report03:
008360  1  C0 03                CPY #03
008362  1  D0 17                BNE Report02
008364  1               FailNo65816:
008364  1  20 17 85             JSR PRNTSTR
008367  1  0D 36 35 38          .BYTE $0D,"65816 not fitted",$0D
00836B  1  31 36 20 6E  
00836F  1  6F 74 20 66  
008379  1  EA                   NOP
00837A  1  60                   RTS
00837B  1               Report02:
00837B  1  C0 02                CPY #$02
00837D  1  D0 25                BNE ReportNext
00837F  1               FailNoHIMEM:
00837F  1  20 17 85             JSR PRNTSTR             ; Print inline text up to NOP
008382  1  20 46 61 69          .BYTE " Fail - HIMEM aliassed to LOMEM",$0D
008386  1  6C 20 2D 20  
00838A  1  48 49 4D 45  
0083A2  1  EA                   NOP
0083A3  1  60                   RTS
0083A4  1               ReportNext:
0083A4  1  C0 01                CPY #$01
0083A6  1  D0 1B                BNE ReportPass
0083A8  1  20 17 85             JSR PRNTSTR             ; Print inline text up to NOP
0083AB  1  20 46 61 69          .BYTE " Fail - data mismatch",$0D
0083AF  1  6C 20 2D 20  
0083B3  1  64 61 74 61  
0083C1  1  EA                   NOP
0083C2  1  60                   RTS
0083C3  1               ReportPass:
0083C3  1  20 17 85             JSR PRNTSTR             ; must be successful if we got here
0083C6  1  20 50 61 73          .BYTE " Pass",$0D
0083CA  1  73 0D        
0083CC  1  EA                   NOP
0083CD  1  60                   RTS
0083CE  1               
0083CE  1                       ;; ------------------------------------------------------------
0083CE  1                       ;; March Elements for the RAM test
0083CE  1                       ;;
0083CE  1                       ;; All are relocatable, and end with RTL so MUST be called via JSL
0083CE  1                       ;;
0083CE  1                       ;; WrDown   - \WR(Acc) - write value of acc to mem in desc. order
0083CE  1                       ;; RdWrDown - \RD(Acc)WR(~Acc)
0083CE  1                       ;; RdWrUp   - /RD(Acc)WR(~Acc)
0083CE  1                       ;;
0083CE  1                       ;; Makes temporary use of page0 location $F6-9
0083CE  1                       ;;
0083CE  1                       ;; Entry A = expected data
0083CE  1                       ;; Exit  Y = 0 (pass) or non-zero (fail)
0083CE  1                       ;;
0083CE  1                       ;; ------------------------------------------------------------
0083CE  1               MARCHSTART:
0083CE  1               
0083CE  1                       ;;\ RD(0)Wr(1)
0083CE  1               RdWrDown:
0083CE  1  85 F6                STA     PZ_BKG0      ; init expected data reg
0083D0  1  49 FF                EOR     #$FF         ; invert it
0083D2  1  EB                   XBA                  ; save it in B register
0083D3  1  A0 00                LDY     #$00         ; y = 0 is a pass
0083D5  1               
0083D5  1  C2 10                REP     #%00010000        ; 16 bit index registers on
0083D7  1                       .I16
0083D7  1  A2 FF FF             LDX     #MEMTOP     ;
0083DA  1               RdWrDown_top:
0083DA  1  BF 00 00 FF          LDA     MEMTESTAREA,X   ; read back data
0083DE  1  EB                   XBA                     ; save it and get inverted data in A
0083DF  1  9F 00 00 FF          STA     MEMTESTAREA,X   ; write inverted data back
0083E3  1  EB                   XBA                     ; restore read data and put inverted back in B
0083E4  1  C5 F6                CMP     PZ_BKG0         ; does it match expected value?
0083E6  1  F0 03                BEQ     RdWrDown_cont   ; if result is zero then all ok
0083E8  1  A0 04 00             LDY     #0004           ; .. else set sticky fail value
0083EB  1               RdWrDown_cont:
0083EB  1  E0 00 00             CPX     #MEMBOT         ; reached membot yet?
0083EE  1  F0 03                BEQ     RdWrDown_exit
0083F0  1  CA                   DEX
0083F1  1  80 E7                BRA     RdWrDown_top
0083F3  1               RdWrDown_exit:
0083F3  1  E2 10                SEP     #%00010000
0083F5  1                       .I8
0083F5  1  6B                   RTL
0083F6  1               
0083F6  1                       ;;/ RD(0)Wr(1)
0083F6  1               RdWrUp:
0083F6  1  85 F6                STA     PZ_BKG0      ; init expected data reg
0083F8  1  49 FF                EOR     #$FF         ; invert it
0083FA  1  EB                   XBA                  ; save it in B register
0083FB  1  A0 00                LDY     #$00         ; y = 0 is a pass
0083FD  1  C2 10                REP     #%00010000        ; 16 bit index registers on
0083FF  1                       .I16
0083FF  1  A2 00 00             LDX     #MEMBOT     ;
008402  1               RdWrUp_top:
008402  1  BF 00 00 FF          LDA     MEMTESTAREA,X   ; read back data
008406  1  EB                   XBA                     ; save it  and get inverted bkg from B
008407  1  9F 00 00 FF          STA     MEMTESTAREA,X   ; write inverted data back
00840B  1  EB                   XBA                     ; restore read data and put inverted data bkg back in B
00840C  1  C5 F6                CMP     PZ_BKG0         ; does it match expected value?
00840E  1  F0 03                BEQ     RdWrUp_cont     ; if result is zero then all ok
008410  1  A0 04 00             LDY     #0004           ; .. else set sticky fail value
008413  1               RdWrUp_cont:
008413  1  E0 FF FF             CPX     #MEMTOP         ; reached memtop yet?
008416  1  F0 03                BEQ     RdWrUp_exit
008418  1  E8                   INX
008419  1  80 E7                BRA     RdWrUp_top
00841B  1               RdWrUp_exit:
00841B  1  E2 10                SEP     #%00010000
00841D  1                       .I8
00841D  1  6B                   RTL
00841E  1               
00841E  1                       ;; \WR(0)
00841E  1               WrDown:
00841E  1  C2 10                REP     #%00010000
008420  1                       .I16
008420  1  A2 FF FF             LDX     #MEMTOP
008423  1               WrDown_top:
008423  1  9F 00 00 FF          STA     MEMTESTAREA,X       ; write inverted data back
008427  1  E0 00 00             CPX     #MEMBOT             ; reached membot yet?
00842A  1  F0 03                BEQ     WrDown_exit
00842C  1  CA                   DEX
00842D  1  80 F4                BRA     WrDown_top
00842F  1               WrDown_exit:
00842F  1  E2 10                SEP     #%00010000
008431  1                       .I8
008431  1  6B                   RTL
008432  1  EA                   NOP
008433  1               MARCHEND:
008433  1               
008433  1                       ;; ----------------------------------------------------------------------
008433  1                       ;; HITESTHIMEM (HITESTHIMEM)
008433  1                       ;;
008433  1                       ;; Very simple test of a 64K byte area of HIMEM. Identical
008433  1                       ;; to TESTHIMEM, except that the march test code is first
008433  1                       ;; relocated to himemory (with all RTS opcode replaced by
008433  1                       ;; RTL) and then called using JSL.
008433  1                       ;;
008433  1                       ;; Test operation, including checking first for CPU type etc
008433  1                       ;; is totally identical to the TESTHIMEM code.
008433  1                       ;;
008433  1                       ;; ----------------------------------------------------------------------
008433  1                       ;; Check 65816 is fitted first
008433  1               HITESTHIMEM:
008433  1  20 D2 82             JSR DieIfNot65816
008436  1               
008436  1                       ;; Check HiMem is fitted next before testing it
008436  1  20 E0 82             JSR DieIfNoHiMem
008439  1               
008439  1  20 1E 88             JSR MSG_BLOCKCPY
00843C  1  78 18 FB             MAC_MODE816  ; switch to Native mode for 16-bit index registers
00843F  1               
00843F  1               BlockCopy:
00843F  1  C2 30                REP #%00110000        ; 16 bit index registers on
008441  1                       .I16
008441  1                       .A16
008441  1  A2 CE 83             LDX #MARCHSTART
008444  1  A0 00 50             LDY #(HIMARCHSTART & $0FFFF)
008447  1  A9 65 00             LDA #CODESIZE
00844A  1  8B                   PHB                     ; save DBR
00844B  1                       ;; Opcode should be <MVN> <dest> <src>
00844B  1  54 FE 00             MVN ^HIMARCHSTART, ^MARCHSTART
00844E  1  AB                   PLB                    ; restore DBR
00844F  1  E2 30                SEP #%00110000 ; Back to 8b registers
008451  1                       .I8
008451  1                       .A8
008451  1               
008451  1               BlockCpyEnd:
008451  1               
008451  1  38 FB EA EA          MAC_MODE02
008455  1  58           
008456  1  20 17 85             JSR PRNTSTR
008459  1  20 44 6F 6E          .BYTE " Done",$0D,"March0: >wr(0)      .."
00845D  1  65 0D 4D 61  
008461  1  72 63 68 30  
008475  1  EA                   NOP
008476  1               
008476  1  A9 55                LDA #$55
008478  1                       ;; NB have to be in 816 mode before calling hi memory via JSL
008478  1                       ;; actually, need 816 mode for 16-bit index registers
008478  1                       ;;   and interrupts disabled because we have no 816 IRQ handler
008478  1                       ;;   But: we could call into hi memory using JSL in Emulated mode,
008478  1                       ;;   provided we had disabled interrupts or had a PBK safe copy
008478  1  78 18 FB             MAC_MODE816
00847B  1  22 50 50 FE          JSL HI_WrDown
00847F  1  38 FB EA EA          MAC_MODE02
008483  1  58           
008484  1               
008484  1  20 BA 84             JSR PrintDoneandAnnounceMarch1
008487  1               
008487  1  A9 55                LDA #$55
008489  1  78 18 FB             MAC_MODE816
00848C  1  22 00 50 FE          JSL HI_RdWrDown
008490  1  38 FB EA EA          MAC_MODE02
008494  1  58           
008495  1               
008495  1  20 DB 84             JSR ReportAndAnnounceMarch2   ; result is in Y
008498  1               
008498  1  A9 AA                LDA #$AA
00849A  1  78 18 FB             MAC_MODE816
00849D  1  22 28 50 FE          JSL HI_RdWrUp
0084A1  1  38 FB EA EA          MAC_MODE02
0084A5  1  58           
0084A6  1               
0084A6  1  20 F9 84             JSR ReportAndAnnounceMarch3   ; result is in Y
0084A9  1               
0084A9  1  A9 55                LDA #$55
0084AB  1  78 18 FB             MAC_MODE816
0084AE  1  22 28 50 FE          JSL HI_RdWrUp
0084B2  1  38 FB EA EA          MAC_MODE02
0084B6  1  58           
0084B7  1               
0084B7  1  4C 51 83             JMP ReportResult        ; result is in Y
0084BA  1                       ; done
0084BA  1               
0084BA  1               PrintDoneandAnnounceMarch1:
0084BA  1  20 17 85             JSR PRNTSTR
0084BD  1  20 44 6F 6E          .BYTE " Done",$0D,"March1: >rd(0)wr(1) .."
0084C1  1  65 0D 4D 61  
0084C5  1  72 63 68 31  
0084D9  1  EA                   NOP
0084DA  1  60                   RTS
0084DB  1               
0084DB  1               ReportAndAnnounceMarch2:
0084DB  1  20 51 83             JSR ReportResult        ; result is in Y
0084DE  1  20 17 85             JSR PRNTSTR
0084E1  1  4D 61 72 63          .BYTE "March2: <rd(1)wr(0) .."
0084E5  1  68 32 3A 20  
0084E9  1  3C 72 64 28  
0084F7  1  EA                   NOP
0084F8  1  60                   RTS
0084F9  1               
0084F9  1               ReportAndAnnounceMarch3:
0084F9  1  20 51 83             JSR ReportResult        ; result is in Y
0084FC  1  20 17 85             JSR PRNTSTR
0084FF  1  4D 61 72 63          .BYTE "March3: <rd(0)wr(1) .."
008503  1  68 33 3A 20  
008507  1  3C 72 64 28  
008515  1  EA                   NOP
008516  1  60                   RTS
008517  1               
008517  1                       ;; ----------------------------------------------------------------------
008517  1                       ;; Print inline text up to NOP
008517  1                       ;; zero page usage: F6 and F7
008517  1                       ;; ----------------------------------------------------------------------
008517  1               PRNTSTR:
008517  1  68                   PLA
008518  1  85 F6                STA $F6
00851A  1  68                   PLA
00851B  1  85 F7                STA $F7                 ;Pop return address to &F6/7
00851D  1  98                   TYA
00851E  1  48                   PHA
00851F  1  A0 00                LDY #$00
008521  1  F0 03                BEQ PRNTSTRBGN
008523  1               PRNTSTRNXT:
008523  1  20 E3 FF             JSR OSASCI
008526  1               PRNTSTRBGN:
008526  1  E6 F6                INC $F6
008528  1  D0 02                BNE PRNTSTRSKP
00852A  1  E6 F7                INC $F7                 ; Increment address
00852C  1               PRNTSTRSKP:
00852C  1  B1 F6                LDA ($F6),Y             ; Get character
00852E  1  C9 EA                CMP #$EA
008530  1  D0 F1                BNE PRNTSTRNXT          ; If not 'NOP' opcode, loop to print it
008532  1  68                   PLA
008533  1  A8                   TAY
008534  1  6C F6 00             JMP ($00F6)             ; Pop Y and jump back to code
008537  1               
008537  1                       ;; ----------------------------------------------------------------------
008537  1                       ;; (*)REPORTCPU
008537  1                       ;;
008537  1                       ;; Detect and display CPU type
008537  1                       ;; ----------------------------------------------------------------------
008537  1               REPORTCPU:
008537  1  20 B0 85             JSR DetectCPUType
00853A  1  48                   PHA
00853B  1  20 17 85             JSR PRNTSTR             	; Print inline text up to NOP
00853E  1  0D                   .BYTE 13
00853F  1  20 44 65 74          .BYTE " Detected "
008543  1  65 63 74 65  
008547  1  64 20        
008549  1  EA                   NOP
00854A  1  68                   PLA
00854B  1  C9 00                CMP #$00
00854D  1  D0 19                BNE DetectionNot6502
00854F  1  20 17 85             JSR PRNTSTR             	; Print inline text up to NOP
008552  1  6F 72 69 67          .BYTE "original NMOS 6502",$0D
008556  1  69 6E 61 6C  
00855A  1  20 4E 4D 4F  
008565  1  0D                   .BYTE 13
008566  1  EA                   NOP
008567  1  60                   RTS
008568  1               DetectionNot6502:
008568  1  C9 01                CMP #$01
00856A  1  D0 15                BNE DetectionNotCMOS6502
00856C  1  20 17 85             JSR PRNTSTR                     ; Print inline text up to NOP
00856F  1  53 74 61 6E          .BYTE "Standard 65C02",$0D
008573  1  64 61 72 64  
008577  1  20 36 35 43  
00857E  1  0D                   .BYTE 13
00857F  1  EA                   NOP
008580  1  60                   RTS
008581  1               DetectionNotCMOS6502:
008581  1  C9 02                CMP #$02
008583  1  D0 16        	BNE DetectionNotRockwell
008585  1  20 17 85     	JSR PRNTSTR              	; Print inline text up to NOP
008588  1  52 6F 63 6B  	.BYTE "Rockwell R65C02",$0D
00858C  1  77 65 6C 6C  
008590  1  20 52 36 35  
008598  1  0D           	.BYTE 13
008599  1  EA           	NOP
00859A  1  60           	RTS
00859B  1               DetectionNotRockwell:
00859B  1  20 17 85     	JSR PRNTSTR              	; Print inline text up to NOP
00859E  1  36 35 38 30  	.BYTE "65802 or 65816",$0D
0085A2  1  32 20 6F 72  
0085A6  1  20 36 35 38  
0085AD  1  0D           	.BYTE 13
0085AE  1  EA           	NOP
0085AF  1  60           	RTS
0085B0  1                       ; detect the CPU type
0085B0  1               	; code is from
0085B0  1               	;   comp.sys.apple2
0085B0  1               	;   Re: Enhanced //e with a 6503??!
0085B0  1               	;   David Empson  Sun, 2 Apr 2006
0085B0  1               	;
0085B0  1               	; return in A
0085B0  1               	;    0 6502
0085B0  1               	;    1 Standard 65C02
0085B0  1               	;    2 Rockwell R65C02
0085B0  1               	;    3 65802 or 65816
0085B0  1               	;
0085B0  1               DetectCPUType:
0085B0  1  A0 00        	LDY #$00
0085B2  1  F8           	SED
0085B3  1  A9 99        	LDA #$99
0085B5  1  18           	CLC
0085B6  1  69 01        	ADC #$01
0085B8  1  D8           	CLD
0085B9  1  30 15        	BMI DetectionDone  	; 6502 N flag not affected by decimal add
0085BB  1  A0 03        	LDY #$03
0085BD  1  A2 00        	LDX #$00
0085BF  1  BB           	.BYTE $BB               ; TYX - 65802 instruction, NOP on all 65C02s
0085C0  1  D0 0E        	BNE DetectionDone  	; Branch only on 65802/816
0085C2  1  A6 F6        	LDX $F6          	; non-destructive use of location $F6 (should maybe disable interrupts first)
0085C4  1  88           	DEY
0085C5  1  84 F6        	STY $F6
0085C7  1  17           	.BYTE $17
0085C8  1  EA                   .BYTE $EA
0085C9  1                	; RMB1 $F6       	; Rockwell R65C02 instruction
0085C9  1  C4 F6        	CPY $F6          	; Location $F6 unaffected on other 65C02
0085CB  1  86 F6        	STX $F6
0085CD  1  D0 01        	BNE DetectionDone      	; Branch only on Rockwell R65C02 (test CPY)
0085CF  1  88           	DEY
0085D0  1               DetectionDone:
0085D0  1  98           	TYA
0085D1  1  60           	RTS
0085D2  1               
0085D2  1                       ;; ----------------------------------------------------------------------
0085D2  1                       ;; (*)SetSerialRedirect
0085D2  1                       ;;
0085D2  1                       ;; setup 19200 baud and redirect both in and out.
0085D2  1                       ;; ----------------------------------------------------------------------
0085D2  1               SetSerialRedirect:
0085D2  1  A9 B5                LDA #181
0085D4  1  A2 00                LDX #0
0085D6  1  A0 00                LDY #0
0085D8  1  20 F4 FF             JSR OSBYTE
0085DB  1                       ;; Second entry point skips the *FX 181 call which seems to
0085DB  1                       ;; hang the machine if used at boot time. So, the *Setser.. command
0085DB  1                       ;; enters at the top and the call from BootFS enters below.
0085DB  1               SetSerialRedirect2:
0085DB  1  A9 07                LDA #7
0085DD  1  A2 08                LDX #8
0085DF  1  20 F4 FF             JSR OSBYTE
0085E2  1  A9 08                LDA #8
0085E4  1  A2 08                LDX #8
0085E6  1  20 F4 FF             JSR OSBYTE
0085E9  1  A9 03                LDA #3
0085EB  1  A2 05                LDX #5
0085ED  1  20 F4 FF             JSR OSBYTE
0085F0  1  A9 02                LDA #2
0085F2  1  A2 01                LDX #1
0085F4  1  20 F4 FF             JSR OSBYTE
0085F7  1                       ;; VDU 15 to turn off page mode
0085F7  1  A9 0F                LDA #15
0085F9  1  4C EE FF             JMP OSWRCH
0085FC  1                       ; done
0085FC  1               
0085FC  1                       ;; ----------------------------------------------------------
0085FC  1                       ;; BootFS - initialize the ROM at boot time
0085FC  1                       ;; ----------------------------------------------------------
0085FC  1               BootFS:
0085FC  1  20 22 86             JSR PrintRomTitle
0085FF  1  20 37 85             JSR REPORTCPU
008602  1  20 B0 85             JSR DetectCPUType
008605  1  C9 03                CMP #$03
008607  1  D0 00                BNE DetectKey
008609  1               ;        JSR DetectHiMem
008609  1               ;        CPY #$00
008609  1               ;        BNE DetectKey
008609  1               ;        JSR OSCOPY
008609  1               ;        JSR MEMCOPY
008609  1               ;        JSR OVERLAYON
008609  1               DetectKey:
008609  1                       ;; detect any key pressed
008609  1  A9 7A                LDA#$7A
00860B  1  20 F4 FF             JSR OSBYTE
00860E  1  E0 FF                CPX #$FF
008610  1  D0 03                BNE BootFSSkip1
008612  1                       ;; redirect the serial if no key was pressed
008612  1  20 DB 85             JSR SetSerialRedirect2
008615  1               BootFSSkip1:
008615  1  60                   RTS
008616  1               
008616  1                       ;; ----------------------------------------------------------
008616  1                       ;; SERVICE 3 - BOOT FS
008616  1                       ;; ----------------------------------------------------------
008616  1               Service3Reset:
008616  1  48                   PHA                     ; we should not claim this service
008617  1               ;;         JSR PRNTSTR             ; Print inline text up to NOP
008617  1               ;;         .BYTE $0D,"BOOT816 saw a service 3",$0D
008617  1               ;;         NOP
008617  1  20 FC 85             JSR BootFS
00861A  1  68                   PLA
00861B  1  60                   RTS
00861C  1               
00861C  1                       ;; ----------------------------------------------------------
00861C  1                       ;; SERVICE &27 - RESET
00861C  1                       ;;
00861C  1                       ;; We have never seen this on a BBC but it seems to be how
00861C  1                       ;; the ROM is initialized on a Master128
00861C  1                       ;; ----------------------------------------------------------
00861C  1               Service27Reset:
00861C  1  48                   PHA                 ;we should not claim this service
00861D  1               ;;        JSR PRNTSTR         ;Print inline text up to NOP
00861D  1               ;;        .BYTE 13,"Boot816 saw a service 27",13
00861D  1               ;;        NOP
00861D  1  20 FC 85             JSR BootFS
008620  1  68                   PLA
008621  1  60                   RTS
008622  1               
008622  1                       ;; ---------------------------------------------------------
008622  1                       ;; Print ROM title
008622  1                       ;; ---------------------------------------------------------
008622  1               PrintRomTitle:
008622  1  A2 FF                LDX #$FF
008624  1  A9 0D                LDA #$0D                ; Prepare to print newline
008626  1               PrintRomTitleNext:
008626  1  20 E3 FF             JSR OSASCI
008629  1  E8                   INX
00862A  1  BD 09 80             LDA TITLE,X
00862D  1  D0 F7                BNE PrintRomTitleNext
00862F  1  60                   RTS
008630  1               
008630  1                       ;; ---------------------------------------------------------
008630  1                       ;; Run multiple iterations of testhimem and hitesthimem
008630  1                       ;; ---------------------------------------------------------
008630  1               
008630  1               BIST20:
008630  1  A9 14                LDA #20
008632  1  48           BIST:   PHA
008633  1  20 EC 82             JSR TESTHIMEM
008636  1  20 33 84             JSR HITESTHIMEM
008639  1  68                   PLA
00863A  1  3A                   DEC
00863B  1  D0 F5                BNE BIST
00863D  1  60                   RTS
00863E  1               
00863E  1                       ;; ---------------------------------------------------------
00863E  1                       ;; Stop the machine, copy some host RAM into HIRAM
00863E  1                       ;; then enable the remapping in CPLD, allow machine to continue
00863E  1                       ;; ---------------------------------------------------------
00863E  1                       .DEFINE         PZ_NMI         $F6
00863E  1                       .DEFINE         NMI_HANDLER    $0D00
00863E  1               	.DEFINE		LOMEM_MAPSTART $0000
00863E  1               	.DEFINE		HIMEM_MAPSTART $FE0000
00863E  1               	.DEFINE		HIMEM_MAPLEN   $8000    ; overlay covers 32K now
00863E  1               	.DEFINE		CPLD_MAPREG    $800003
00863E  1               	.DEFINE		CPLD_MAPMASK   $10      ; NB bits 0..3 are clock control bits and not to be disturbed
00863E  1               
00863E  1               OVERLAYON:
00863E  1               
00863E  1  20 D2 82     	JSR DieIfNot65816
008641  1  78 18 FB     	MAC_MODE816   ; also sets interrupt mask
008644  1               	; nobble the NMI handler temporarily
008644  1  AD 00 0D     	LDA NMI_HANDLER
008647  1  85 F6        	STA PZ_NMI
008649  1  A9 40                LDA #$40  ; RTI
00864B  1  8D 00 0D     	STA NMI_HANDLER
00864E  1               
00864E  1  8B                   PHB                     ; save DBR because block moves change it
00864F  1               
00864F  1               	;; copy low (host) memory into high (fast) memory
00864F  1               	;; block copy routine - ought really to re-use this code
00864F  1  C2 30                REP #%00110000        ; 16 bit index registers on
008651  1                       .I16
008651  1                       .A16
008651  1                       ;; MVN <destbank> <srcbank> with Y as dest addr, X as source addr, A as bytecount-1
008651  1  A2 00 00             LDX #LOMEM_MAPSTART            ;; lower 16 bits of source
008654  1  A0 00 00             LDY #(HIMEM_MAPSTART & $ffff)  ;; lower 16 bits of destination
008657  1  A9 FF 7F             LDA #HIMEM_MAPLEN-1
00865A  1  54 FE 00             MVN ^HIMEM_MAPSTART, ^LOMEM_MAPSTART
00865D  1  E2 30                SEP #%00110000 ; Back to 8b registers
00865F  1                       .I8
00865F  1                       .A8
00865F  1               
00865F  1                       ; switch in the memory mapping using 24-bit addressing
00865F  1  AF 03 00 80  	LDA CPLD_MAPREG
008663  1  09 10        	ORA #CPLD_MAPMASK
008665  1  8F 03 00 80  	STA CPLD_MAPREG
008669  1               
008669  1  AB                   PLB                     ; restore DBR (from the stack in the mapped state)
00866A  1               
00866A  1                       ; restore the NMI handler
00866A  1  A5 F6                LDA PZ_NMI
00866C  1  8D 00 0D             STA NMI_HANDLER
00866F  1               
00866F  1  38 FB EA EA  	MAC_MODE02 ; also re-enables interrupts
008673  1  58           
008674  1  60           	RTS
008675  1               
008675  1               OVERLAYOFF:
008675  1  20 D2 82     	JSR DieIfNot65816
008678  1  78 18 FB     	MAC_MODE816   ; also sets interrupt mask
00867B  1               	; nobble the NMI handler temporarily
00867B  1  AD 00 0D     	LDA NMI_HANDLER
00867E  1  85 F6        	STA PZ_NMI
008680  1  A9 40                LDA #$40  ; RTI
008682  1  8D 00 0D     	STA NMI_HANDLER
008685  1               
008685  1  8B                   PHB                     ; save DBR because block moves change it
008686  1               				; take care to save in the mapped state
008686  1               				; so when we copy down, it's there to retrieve
008686  1               
008686  1                       ; switch out the memory mapping by clearing the control bit
008686  1  AF 03 00 80  	LDA CPLD_MAPREG
00868A  1  29 EF        	AND #($ff-CPLD_MAPMASK)
00868C  1  8F 03 00 80  	STA CPLD_MAPREG
008690  1               
008690  1               	;; block copy routine - ought really to re-use this code
008690  1  C2 30                REP #%00110000        ; 16 bit index registers on
008692  1                       .I16
008692  1                       .A16
008692  1                       ;; MVN <destbank> <srcbank> with Y as dest addr, X as source addr, A as bytecount-1
008692  1  A2 00 00             LDX #(HIMEM_MAPSTART & $ffff)  ;; lower 16 bits of source
008695  1  A0 00 00             LDY #LOMEM_MAPSTART            ;; lower 16 bits of destination
008698  1  A9 FF 7F             LDA #HIMEM_MAPLEN-1
00869B  1  54 00 FE             MVN ^LOMEM_MAPSTART, ^HIMEM_MAPSTART
00869E  1  AB                   PLB                     ; restore DBR
00869F  1  E2 30                SEP #%00110000 ; Back to 8b registers
0086A1  1                       .I8
0086A1  1                       .A8
0086A1  1               
0086A1  1                       ; restore the NMI handler
0086A1  1  A5 F6                LDA PZ_NMI
0086A3  1  8D 00 0D             STA NMI_HANDLER
0086A6  1               
0086A6  1  38 FB EA EA  	MAC_MODE02 ; also re-enables interrupts
0086AA  1  58           
0086AB  1  60           	RTS
0086AC  1               
0086AC  1                       ;; ---------------------------------------------------------
0086AC  1                       ;; a fixed copy of 16k of SWROM 15 from bank 0 to FE
0086AC  1                       ;; *MEMCOPY
0086AC  1               	;; note that variable banks means patching the code
0086AC  1               	;; note that the code must be in RAM anyway to read ROM
0086AC  1               	;;   possible but slower to use OSRDRM to read a byte at a time
0086AC  1               	;;
0086AC  1               	;; we might one day want a generic MEMCOPY with parameters
0086AC  1               	;; perhaps this should be called ROMCOPY
0086AC  1                       ;; ---------------------------------------------------------
0086AC  1                       .DEFINE         MEMCOPY_SRC	      $8000
0086AC  1               	.DEFINE		MEMCOPY_SOURCE_ROM      $0F  ; default to copying with ROM 15 in the map
0086AC  1                       .DEFINE         MEMCOPY_DST         $FE8000  ; for testing: $018000
0086AC  1                       .DEFINE         MEMCOPY_LEN           $4000  ; just copy one ROM's worth
0086AC  1               	.DEFINE		ZP_PTR_1	        $70
0086AC  1               
0086AC  1               MEMCOPY:
0086AC  1  20 D2 82     	JSR DieIfNot65816
0086AF  1               
0086AF  1               	;; allocate space on the stack
0086AF  1  BA           	TSX
0086B0  1  8A           	TXA
0086B1  1  A8           	TAY ; original stack ptr
0086B2  1  38           	SEC
0086B3  1  E9 2B        	SBC #(MEMCOPYCODE_END - MEMCOPYCODE + 1)
0086B5  1  AA           	TAX
0086B6  1  9A           	TXS
0086B7  1  5A           	PHY ; save original stack ptr so we can de-allocate
0086B8  1               
0086B8  1               	; init our pointer to the stack area
0086B8  1  1A           	INC A
0086B9  1  85 70        	STA ZP_PTR_1
0086BB  1  A9 01        	LDA #1			; stack is certainly page 1 - we're in emulation mode
0086BD  1  85 71        	STA ZP_PTR_1+1
0086BF  1               
0086BF  1  A0 2A        	LDY #(MEMCOPYCODE_END - MEMCOPYCODE)
0086C1  1               MEMCOPY_BACK_1:
0086C1  1  B9 17 87     	LDA MEMCOPYCODE,Y
0086C4  1  91 70        	STA (ZP_PTR_1),Y
0086C6  1  88           	DEY
0086C7  1  10 F8        	BPL MEMCOPY_BACK_1	; we copy fewer than 127 bytes
0086C9  1               
0086C9  1               	; fake an indirect subroutine call
0086C9  1  A9 86        	LDA #>(MEMCOPY_DONE-1)
0086CB  1  48           	PHA
0086CC  1  A9 D1        	LDA #<(MEMCOPY_DONE-1)
0086CE  1  48           	PHA
0086CF  1  6C 70 00     	JMP (ZP_PTR_1)
0086D2  1               MEMCOPY_DONE:
0086D2  1               
0086D2  1               	;; to debug this, bear in mind that about 9 bytes of what we place
0086D2  1                	;; will have been overwritten by the time we return to CLI
0086D2  1               
0086D2  1               	;; free space on the stack
0086D2  1  FA           	PLX
0086D3  1  9A           	TXS
0086D4  1  60           	RTS
0086D5  1               
0086D5  1                       ;; ---------------------------------------------------------
0086D5  1                       ;; OS-ROM-copy: copy 15k and 256bytes from bank0 to himem
0086D5  1                       ;; *OSCOPY
0086D5  1               	;; much code duplication with MEMCOPY - could be shared
0086D5  1                       ;; ---------------------------------------------------------
0086D5  1                       .DEFINE         OSCOPY_SRC	     $C000
0086D5  1                       .DEFINE         OSCOPY_DST         $FEC000  ; implicit - not used
0086D5  1                       .DEFINE         COPY_LEN             $3C00  ; 31k
0086D5  1               
0086D5  1               OSCOPY:
0086D5  1  20 D2 82     	JSR DieIfNot65816
0086D8  1               
0086D8  1               	;; allocate space on the stack
0086D8  1  BA           	TSX
0086D9  1  8A           	TXA
0086DA  1  A8           	TAY ; original stack ptr
0086DB  1  38           	SEC
0086DC  1  E9 2B        	SBC #(MEMCOPYCODE_END - MEMCOPYCODE + 1)
0086DE  1  AA           	TAX
0086DF  1  9A           	TXS
0086E0  1  5A           	PHY ; save original stack ptr so we can de-allocate
0086E1  1               
0086E1  1               	; init our pointer to the stack area
0086E1  1  1A           	INC A
0086E2  1  85 70        	STA ZP_PTR_1
0086E4  1  A9 01        	LDA #1			; stack is certainly page 1 - we're in emulation mode
0086E6  1  85 71        	STA ZP_PTR_1+1
0086E8  1               
0086E8  1  A0 2A        	LDY #(MEMCOPYCODE_END - MEMCOPYCODE)
0086EA  1               OSCOPY_BACK_1:
0086EA  1  B9 17 87     	LDA MEMCOPYCODE,Y
0086ED  1  91 70        	STA (ZP_PTR_1),Y
0086EF  1  88           	DEY
0086F0  1  10 F8        	BPL OSCOPY_BACK_1	; we copy fewer than 127 bytes
0086F2  1               
0086F2  1               	;; patch up the copying routine before using it
0086F2  1  A9 C0        	LDA #>(OSCOPY_SRC)
0086F4  1  83 14        	STA MEMCOPY_PATCH_SRC-MEMCOPYCODE+4,S
0086F6  1  83 17        	STA MEMCOPY_PATCH_DEST-MEMCOPYCODE+4,S
0086F8  1  A9 3B        	LDA #>(COPY_LEN-1)
0086FA  1  83 1A        	STA MEMCOPY_PATCH_LEN-MEMCOPYCODE+4,S
0086FC  1               
0086FC  1               	;; copy just a little more: ff00 to ffff inclusive
0086FC  1  A2 00        	LDX #0
0086FE  1  FC 70 00     	JSR (ZP_PTR_1,X)
008701  1               	;; patch up the copying routine before using it
008701  1  A9 FF        	LDA #$ff
008703  1  83 14        	STA MEMCOPY_PATCH_SRC-MEMCOPYCODE+4,S
008705  1  83 17        	STA MEMCOPY_PATCH_DEST-MEMCOPYCODE+4,S
008707  1  A9 FF        	LDA #$ff
008709  1  83 19        	STA MEMCOPY_PATCH_LEN-MEMCOPYCODE+3,S
00870B  1  A9 00        	LDA #$0
00870D  1  83 1A        	STA MEMCOPY_PATCH_LEN-MEMCOPYCODE+4,S
00870F  1               
00870F  1  A2 00        	LDX #0
008711  1  FC 70 00     	JSR (ZP_PTR_1,X)
008714  1               
008714  1               OSCOPY_DONE:
008714  1               	;; to debug this, bear in mind that about 9 bytes of what we place
008714  1                	;; will have been overwritten by the time we return to CLI
008714  1               
008714  1               	;; deallocate our stack usage
008714  1  FA           	PLX
008715  1  9A           	TXS
008716  1  60           	RTS
008717  1               
008717  1                       ;; ---------------------------------------------------------
008717  1                       ;; Code to be copied into RAM so it can copy SWROM
008717  1               	;; Has extra labels so it can be patched in various places
008717  1               	;; 43 bytes ($2B bytes) approx - can fit onto stack
008717  1                       ;; ---------------------------------------------------------
008717  1               MEMCOPYCODE:
008717  1               
008717  1  A5 F4        	LDA ROMLATCHCOPY ; take a safe copy of the current ROM
008719  1  48           	PHA
00871A  1               
00871A  1               MEMCOPY_PATCH_ROM:
00871A  1  A9 0F        	LDA #MEMCOPY_SOURCE_ROM
00871C  1               
00871C  1  85 F4        	STA ROMLATCHCOPY
00871E  1  8D 30 FE     	STA ROMLATCH
008721  1               
008721  1  78 18 FB             MAC_MODE816   ; also sets interrupt mask
008724  1               	;; note that the PHB/PLB may have to be external to the block copy
008724  1                       ;; to cope with the overlay case
008724  1  8B                   PHB                     ; save DBR because block moves change it
008725  1               
008725  1                       ;; block copy routine - ought really to re-use this code
008725  1  C2 30                REP #%00110000        ; 16 bit index registers on
008727  1                       .I16
008727  1                       .A16
008727  1                       ;; MVN <destbank> <srcbank> with Y as dest addr, X as source addr, A as bytecount-1
008727  1               
008727  1               MEMCOPY_PATCH_SRC:
008727  1  A2 00 80             LDX #MEMCOPY_SRC            ;; lower 16 bits of source
00872A  1               MEMCOPY_PATCH_DEST:
00872A  1  A0 00 80             LDY #(MEMCOPY_DST & $ffff)  ;; lower 16 bits of destination
00872D  1               MEMCOPY_PATCH_LEN:
00872D  1  A9 FF 3F             LDA #(MEMCOPY_LEN-1)
008730  1               MEMCOPY_PATCH_MVN:
008730  1  54 FE 00             MVN ^MEMCOPY_DST, $0
008733  1  E2 30                SEP #%00110000 ; Back to 8b registers
008735  1                       .I8
008735  1                       .A8
008735  1               
008735  1  AB                   PLB                     ; restore DBR
008736  1               
008736  1  38 FB EA EA          MAC_MODE02 ; also re-enables interrupts
00873A  1  58           
00873B  1               
00873B  1               	;; re-select the original ROM
00873B  1  68           	PLA
00873C  1  85 F4        	STA ROMLATCHCOPY
00873E  1  8D 30 FE     	STA ROMLATCH
008741  1               
008741  1               MEMCOPYCODE_END:
008741  1  60                   RTS
008742  1               
008742  1               
008742  1                       ;; ---------------------------------------------------------
008742  1                       ;; Take a 24-bit address and print the byte found there
008742  1                       ;; *HIPEEK FFFFE
008742  1                       ;; ---------------------------------------------------------
008742  1               HIPEEK:
008742  1  98                   TYA                    ;; Y is part of our command-line pointer
008743  1  48                   PHA
008744  1  20 D2 82             JSR DieIfNot65816
008747  1  68                   PLA
008748  1  A8                   TAY
008749  1               
008749  1  A9 06                LDA #6                 ;; read up to 6 hex digits
00874B  1  20 62 88             JSR argparse           ;; place a 24-bit address in 70/71/72
00874E  1  B0 4D                BCS HIPEEKPOKEFAIL
008750  1               
008750  1  20 0F 88             JSR print24bits
008753  1  20 E7 FF             JSR OSNEWL
008756  1               
008756  1               HIPEEK_peek:
008756  1                       ; we're using 24-bit addressing in emulated mode: that's OK
008756  1  A7 70                LDA [$70]
008758  1  20 D7 88             JSR printhex1byte
00875B  1  4C E7 FF             JMP OSNEWL
00875E  1                       ; done
00875E  1               
00875E  1                       ;; ---------------------------------------------------------
00875E  1                       ;; Write a given byte to a given 24-bit address
00875E  1                       ;; *HIPOKE 80000 ED
00875E  1                       ;; grubby in part because the arg parser has a poor interface
00875E  1                       ;; ---------------------------------------------------------
00875E  1               HIPOKE:
00875E  1  98                   TYA                    ;; Y is part of our command-line pointer
00875F  1  48                   PHA
008760  1  20 D2 82             JSR DieIfNot65816
008763  1  68                   PLA
008764  1  A8                   TAY
008765  1               
008765  1  A9 06                LDA #6                 ;; read up to 6 hex digits
008767  1  20 62 88             JSR argparse           ;; place a 24-bit address in 70/71/72
00876A  1  B0 31                BCS HIPEEKPOKEFAIL
00876C  1               
00876C  1  20 0F 88             JSR print24bits
00876F  1  20 E7 FF             JSR OSNEWL
008772  1               
008772  1  A5 70                LDA $70                ;; save the address - we're about to overwrite
008774  1  48                   PHA
008775  1  A5 71                LDA $71
008777  1  48                   PHA
008778  1  A5 72                LDA $72
00877A  1  48                   PHA
00877B  1               
00877B  1  A9 02                LDA #2                 ;; read a single byte of hex
00877D  1  20 62 88             JSR argparse           ;; return a one-byte datum in A8
008780  1  B0 18                BCS HIPEEKPOKEFAIL3POP
008782  1               
008782  1  20 19 88             JSR print8bits
008785  1  20 E7 FF             JSR OSNEWL
008788  1               
008788  1  A5 70                LDA $70                ;; save the data byte
00878A  1  AA                   TAX
00878B  1  68                   PLA                    ;; now recover the 3-byte address we had
00878C  1  85 72                STA $72
00878E  1  68                   PLA
00878F  1  85 71                STA $71
008791  1  68                   PLA
008792  1  85 70                STA $70
008794  1  8A                   TXA
008795  1                       ; we're using 24-bit addressing in emulated mode: that's OK
008795  1  87 70                STA [$70]
008797  1  4C 56 87             JMP HIPEEK_peek        ;; re-read the value and print it
00879A  1               
00879A  1               HIPEEKPOKEFAIL3POP:
00879A  1  68                   PLA
00879B  1  68                   PLA
00879C  1  68                   PLA
00879D  1               HIPEEKPOKEFAIL:
00879D  1  A0 04                LDY #4
00879F  1  4C 51 83             JMP ReportResult
0087A2  1                       ; done
0087A2  1               
0087A2  1                       ;; ---------------------------------------------------------
0087A2  1                       ;; Dump a region of memory in hex
0087A2  1                       ;; *HEXDUMP AAAAAA BBBBBB
0087A2  1                       ;; A is the starting address, B is the end address
0087A2  1                       ;; ---------------------------------------------------------
0087A2  1               HEXDUMP:
0087A2  1  98                   TYA                    ;; Y is part of our command-line pointer
0087A3  1  48                   PHA
0087A4  1  20 D2 82             JSR DieIfNot65816
0087A7  1  68                   PLA
0087A8  1  A8                   TAY
0087A9  1               
0087A9  1  A9 06                LDA #6                 ;; read up to 6 hex digits
0087AB  1  20 62 88             JSR argparse           ;; place a 24-bit address in 70/71/72
0087AE  1  B0 ED                BCS HIPEEKPOKEFAIL
0087B0  1               
0087B0  1  A5 70                LDA $70                ;; save the address in 73/74/75
0087B2  1  85 73                STA $73
0087B4  1  A5 71                LDA $71
0087B6  1  85 74                STA $74
0087B8  1  A5 72                LDA $72
0087BA  1  85 75                STA $75
0087BC  1               
0087BC  1  A9 06                LDA #6                 ;; read up to 6 hex digits
0087BE  1  20 62 88             JSR argparse           ;; place a 24-bit address in 70/71/72
0087C1  1  B0 DA                BCS HIPEEKPOKEFAIL
0087C3  1               
0087C3  1               	; the addresses are the wrong way around - I really need indirection
0087C3  1  A5 70 EB A5  	MAC_SWAP $70, $73
0087C7  1  73 85 70 EB  
0087CB  1  85 73        
0087CD  1  A5 71 EB A5  	MAC_SWAP $71, $74
0087D1  1  74 85 71 EB  
0087D5  1  85 74        
0087D7  1  A5 72 EB A5  	MAC_SWAP $72, $75
0087DB  1  75 85 72 EB  
0087DF  1  85 75        
0087E1  1               
0087E1  1               HEXDUMP1LINE:
0087E1  1  20 0F 88             JSR print24bits
0087E4  1  A2 10        	LDX #16
0087E6  1               HEXDUMPNEXTBYTE:
0087E6  1  A9 20        	LDA #' '
0087E8  1  20 EE FF     	JSR OSWRCH
0087EB  1  A7 70        	LDA [$70]
0087ED  1  20 D7 88             JSR printhex1byte
0087F0  1  E6 70        	INC $70
0087F2  1  D0 06        	BNE HD_SKIP_1
0087F4  1  E6 71        	INC $71
0087F6  1  D0 02        	BNE HD_SKIP_1
0087F8  1  E6 72        	INC $72
0087FA  1               HD_SKIP_1:
0087FA  1  CA           	DEX
0087FB  1  D0 E9        	BNE HEXDUMPNEXTBYTE
0087FD  1  20 E7 FF             JSR OSNEWL
008800  1               
008800  1  A5 70        	LDA $70  ;; check to see if we're done
008802  1  C5 73        	CMP $73
008804  1  A5 71        	LDA $71
008806  1  E5 74        	SBC $74
008808  1  A5 72        	LDA $72
00880A  1  E5 75        	SBC $75
00880C  1  90 D3        	BCC HEXDUMP1LINE
00880E  1  60           	RTS
00880F  1               
00880F  1               print24bits:
00880F  1  A5 72                LDA $72
008811  1  20 D7 88             JSR printhex1byte
008814  1  A5 71                LDA $71
008816  1  20 D7 88             JSR printhex1byte
008819  1               print8bits:
008819  1  A5 70                LDA $70
00881B  1  4C D7 88             JMP printhex1byte
00881E  1                       ; done
00881E  1               
00881E  1               
00881E  1               .ifdef IRQINSTALL_D
00881E  1                       ;; ---------------------------------------------------------
00881E  1                       ;; Install an 816-mode IRQ handler in high memory
00881E  1               	;;
00881E  1               	;; tested only in emulation. No test routine in ROM.
00881E  1               	;;
00881E  1                       ;; ---------------------------------------------------------
00881E  1               
00881E  1               .define  irqvector816  $FFEE
00881E  1               .define  irqvector02   $FFFE
00881E  1               
00881E  1               IRQINSTALL:
00881E  1                       JSR DieIfNot65816
00881E  1               
00881E  1                       ;; Check HiMem is fitted next before testing it
00881E  1                       JSR DieIfNoHiMem
00881E  1               
00881E  1               	SEI
00881E  1               	LDA # .lobyte(IRQHANDLER)
00881E  1               	STA $FE0000 + irqvector816
00881E  1               	LDA # .hibyte(IRQHANDLER)
00881E  1               	STA $FE0000 + irqvector816 + 1
00881E  1               	CLI
00881E  1               	RTS
00881E  1               
00881E  1               
00881E  1               IRQHANDLER:
00881E  1               	;; irq handling code derived from http://cerebro.xu.edu/~ryanr/atari/65816.html
00881E  1               	;; this is called from the 816 irq vector, so only called in 816 mode
00881E  1               	;; a beeb-hosted 816 must switch to 6502 mode to use the OS handler
00881E  1               	;; or it could handle it itself
00881E  1               	;; note that the machine will already have pushed P and done SEI
00881E  1                       PHD    		; Save DBR and Direct
00881E  1                       PHB
00881E  1                       PEA $0000     	; Clear Direct...
00881E  1                       PLD           	;
00881E  1               	PHK		; ... and with a single zero byte ...
00881E  1                       PLB		; ... clear the DBR
00881E  1                       PHX           	; X&Y saved at present width, because resetting them
00881E  1                       PHY           	;  to 8 bits would destroy the upper half contents.
00881E  1               	PHP  		; push 816 P reg for reg width info (I was set as IRQ vector fetched)
00881E  1               
00881E  1               	;; push a fake interrupt frame so we can call the 6502 host interrupt service
00881E  1               	PER IRETURN   	; push return address (then status) for the RTI
00881E  1               	SEP #%00110000 	; Set 8 bit regs
00881E  1               	LDA #%00000100  ; we want I set and B clear for the 6502 irq handler
00881E  1               	PHA           	; saving for sake of 6502 handler and RTI
00881E  1               
00881E  1               	;; everything is safe
00881E  1               	;; switch to 6502 mode for the host interrupt service routine
00881E  1               	SEC
00881E  1               	XCE
00881E  1               	NOP		; residual doubt about our clock switching?
00881E  1               
00881E  1               	;;        now jump to the appropriate interrupt vector, such as...
00881E  1               	JMP (irqvector02) ; Its RTI will return to IRETURN
00881E  1                       ; done
00881E  1               
00881E  1               
00881E  1               IRETURN:
00881E  1               	CLC		; beeb special:	return to 816-mode (we're in the 816-mode handler!)
00881E  1               	XCE
00881E  1               	PLP 		; recover unmodified 816 status byte - for reg widths
00881E  1               			;  we know this saved P has SEI
00881E  1               	                ; we don't worry about N and Z because the next RTI will pull a real P
00881E  1               	PLY           	;  now restore X&Y at whatever width they were saved at
00881E  1                       PLX           	;
00881E  1                       PLB           	; Restore DBR and Direct
00881E  1                       PLD
00881E  1                       RTI           	; Return to main program (pulling genuine user-mode P then 3 PC bytes)
00881E  1               
00881E  1               .endif
00881E  1               
00881E  1               MSG_BLOCKCPY:
00881E  1  20 17 85             JSR PRNTSTR
008821  1  0D 43 6F 70          .BYTE $0D,"Copying March code to himem .."
008825  1  79 69 6E 67  
008829  1  20 4D 61 72  
008840  1  EA                   NOP
008841  1  60                   RTS
008842  1               
008842  1               MSG_NOHIMEM:
008842  1  20 17 85             JSR PRNTSTR
008845  1  0D 4E 6F 20          .BYTE $0D,"No Himem found - aborting",$0D
008849  1  48 69 6D 65  
00884D  1  6D 20 66 6F  
008860  1  EA                   NOP
008861  1  60                   RTS
008862  1               
008862  1                       ;;
008862  1                       ;; Some code to parse hex args (c) Gordon Horsington from his Module09 file
008862  1                       ;; uses gsinit/gsread to remove quotes and other escape chars
008862  1                       ;; parses the OS string at (&F2),Y
008862  1                       ;; allows up to 6 digits, will zero-extend short input
008862  1                       ;; results returned in 70,71,72 (lsb to msb)
008862  1                       ;; fixme: max number of bytes accepted should be a parameter
008862  1                       ;; fixme: zero page addresses not symbolic
008862  1                       ;; fixme: should be looping not straightlined
008862  1                       ;; fixme: reverses the bytes in order to store lsb first: better to shift into a result
008862  1               
008862  1               argparse:
008862  1  85 77                STA $77       ; save the parameter
008864  1  18                   CLC           ; terminate with space, return or "
008865  1  20 C2 FF             JSR GSINIT    ; initialise argument with Gsinit
008868  1  BA                   TSX
008869  1  86 76                STX $76       ; save the stack pointer so we can error out
00886B  1  A2 00                LDX #0        ; initial result = $000000
00886D  1  86 70                STX $70       ; least sig. byte of result
00886F  1  86 71                STX $71       ;
008871  1  86 72                STX $72       ; most sig. byte of result
008873  1  CA                   DEX           ; X will count number of nybbles - 1
008874  1               argloop:
008874  1  20 C5 FF             JSR GSREAD    ; read character from argument with Gsread
008877  1  B0 07                BCS argend    ; branch if termination character
008879  1  20 B9 88             JSR argconv   ; convert nybble into binary
00887C  1  48                   PHA           ; push each nibble on stack
00887D  1  E8                   INX           ; X is a running count of nibbles
00887E  1  10 F4                BPL argloop   ; branch for next character (limit of 127 chars!)
008880  1               argend:
008880  1  E4 77                CPX $77       ; more than expected number of characters?
008882  1  B0 4E                BCS argerr    ; reject if too many
008884  1               
008884  1  68                   PLA           ; pull a low nibble
008885  1  85 70                STA $70       ; store in appropriate place
008887  1               
008887  1  CA                   DEX           ;
008888  1  30 2D                BMI argdone   ; branch if we're done
00888A  1               
00888A  1  68                   PLA           ; pull a high nibble
00888B  1  0A                   ASL A         ; shift
00888C  1  0A                   ASL A         ; left
00888D  1  0A                   ASL A         ; four
00888E  1  0A                   ASL A         ; bits
00888F  1  05 70                ORA $70       ; OR into appropriate byte
008891  1  85 70                STA $70       ; and store
008893  1               
008893  1  CA                   DEX           ;
008894  1  30 21                BMI argdone   ; branch if we're done
008896  1               
008896  1  68                   PLA           ; pull a low nibble
008897  1  85 71                STA $71       ; store in appropriate place
008899  1               
008899  1  CA                   DEX           ;
00889A  1  30 1B                BMI argdone   ; branch if we're done
00889C  1               
00889C  1  68                   PLA           ; pull a high nibble
00889D  1  0A                   ASL A         ; shift
00889E  1  0A                   ASL A         ; left
00889F  1  0A                   ASL A         ; four
0088A0  1  0A                   ASL A         ; bits
0088A1  1  05 71                ORA $71       ; OR into appropriate byte
0088A3  1  85 71                STA $71       ; and store
0088A5  1               
0088A5  1  CA                   DEX           ;
0088A6  1  30 0F                BMI argdone   ; branch if we're done
0088A8  1               
0088A8  1  68                   PLA           ; pull a low nibble
0088A9  1  85 72                STA $72       ; store in appropriate place
0088AB  1               
0088AB  1  CA                   DEX           ;
0088AC  1  30 09                BMI argdone   ; branch if we're done
0088AE  1               
0088AE  1  68                   PLA           ; pull a high nibble
0088AF  1  0A                   ASL A         ; shift
0088B0  1  0A                   ASL A         ; left
0088B1  1  0A                   ASL A         ; four
0088B2  1  0A                   ASL A         ; bits
0088B3  1  05 72                ORA $72       ; OR into appropriate byte
0088B5  1  85 72                STA $72       ; and store
0088B7  1               
0088B7  1               argdone:
0088B7  1  18                   CLC           ; indicate success
0088B8  1  60                   RTS
0088B9  1               
0088B9  1               argconv:
0088B9  1  C9 3A                CMP #$3A      ; ASC("9")+1
0088BB  1  B0 08                BCS argletters
0088BD  1  C9 30                CMP #$30      ; ASC("0")
0088BF  1  30 11                BMI argerr
0088C1  1  29 0F                AND #$F
0088C3  1  18                   CLC
0088C4  1  60                   RTS
0088C5  1               argletters:
0088C5  1  29 DF                AND #$DF      ; downcase the letters for convenience
0088C7  1  E9 37                SBC #$37
0088C9  1  C9 0A                CMP #$A
0088CB  1  30 05                BMI argerr
0088CD  1  C9 10                CMP #$10
0088CF  1  B0 01                BCS argerr
0088D1  1  60                   RTS
0088D2  1               
0088D2  1               argerr:
0088D2  1  A6 76                LDX $76       ; recover the stack pointer
0088D4  1  9A                   TXS
0088D5  1  38                   SEC           ; indicate failure to caller
0088D6  1  60                   RTS
0088D7  1               
0088D7  1                       ;; other cribs for handling hex found in os1.2 disassembly:
0088D7  1                       ;;   E2AD  shift a hex string into osfile control block at 02ee,X
0088D7  1                       ;;   E08F  check for hex digit
0088D7  1                       ;;   F97A  print ASCII equivalent of hex byte
0088D7  1               
0088D7  1               
0088D7  1                       ;; print ASCII equivalent of hex byte
0088D7  1                       ;; copied from bbc os1.20
0088D7  1               
0088D7  1               printhex1byte:
0088D7  1  48                   PHA         ;save A on stack
0088D8  1  4A                   LSR         ;/16 to put high nybble in lo
0088D9  1  4A                   LSR         ;
0088DA  1  4A                   LSR         ;
0088DB  1  4A                   LSR         ;
0088DC  1  20 E0 88             JSR printhex1nibble  ; print the high nibble first
0088DF  1  68                   PLA         ;get back A
0088E0  1               
0088E0  1               printhex1nibble:
0088E0  1  18                   CLC         ;clear carry flag
0088E1  1  29 0F                AND #$0F    ;clear high nybble
0088E3  1  69 30                ADC #$30    ;Add &30 to convert 0-9 to ASCII A-F to : ; < = > ?
0088E5  1  C9 3A                CMP #$3A    ;if A< ASC(':')
0088E7  1  90 02                BCC printhex1char
0088E9  1  69 06                ADC #$06    ;else add 7 to convert : ; < = > ? to A B C D E F
0088EB  1               printhex1char:
0088EB  1  4C EE FF             JMP OSWRCH  ;print character and return
0088EE  1                       ; done
0088EE  1               
0088EE  1               .ifndef TOPLEVEL
0088EE  1               TOPLEVEL=1
0088EE  1               .endif
0088EE  1               .ifdef SRECORD_D
0088EE  1               .include "srecord.as"
0088EE  2                       ;; ---------------------------------------------------------
0088EE  2                       ;;
0088EE  2                       ;; srecord
0088EE  2                       ;;
0088EE  2                       ;; Srecord loader by Ed Spittles
0088EE  2                       ;;
0088EE  2                       ;; bugs: some redundant code copied in from boot816 rom
0088EE  2                       ;; bugs: using page 6 for string buffer without reservation
0088EE  2                       ;;
0088EE  2                       ;; ---------------------------------------------------------
0088EE  2                       ;; (C) 2009 Ed Spittles
0088EE  2                       ;; some hex handling routines (c) Gordon Horsington from his Module09 file
0088EE  2                       ;; ---------------------------------------------------------
0088EE  2                       ;;
0088EE  2                       ;; $Author:$
0088EE  2                       ;; $Id:$
0088EE  2                       ;; $Rev: 2 $
0088EE  2                       ;;
0088EE  2               .ifndef TOPLEVEL
0088EE  2                       TOPLEVEL=1
0088EE  2                       .SETCPU "65816"
0088EE  2               
0088EE  2                       .ifndef BASE
0088EE  2                       .error  "BASE is not defined - invoke ca65 with e.g.  -D BASE=0x2000 "
0088EE  2                       .endif
0088EE  2                       .ORG BASE
0088EE  2               
0088EE  2                       .DEFINE OSRDCH  $FFE0
0088EE  2                       .DEFINE OSASCI  $FFE3
0088EE  2                       .DEFINE OSNEWL  $FFE7
0088EE  2                       .DEFINE OSWRCH  $FFEE
0088EE  2                       .DEFINE OSWORD  $FFF1
0088EE  2                       .DEFINE OSBYTE  $FFF4
0088EE  2               
0088EE  2                       ;; zero page usage:
0088EE  2                       ;; &F6, &F7  - officially ptr into paged ROM, used here by mem testers and prntstr
0088EE  2                       ;; &A8-&AF   - free for 'os commands' - might be overwritten by OSASCI used by prntstr?
0088EE  2                       ;;           - up to 4 bytes will be used by hipeek and hipoke
0088EE  2               
0088EE  2                       .MACRO MAC_MODE816
0088EE  2                       SEI                     ; disable interrupts and enter 816 mode
0088EE  2                       CLC
0088EE  2                       XCE
0088EE  2                       .ENDMACRO
0088EE  2               
0088EE  2                       .MACRO MAC_MODE02
0088EE  2                       SEC                     ; enter emulation mode and reenable interrupts
0088EE  2                       XCE
0088EE  2                       NOP                     ; delay before re-enabling interrupts
0088EE  2                       NOP
0088EE  2                       CLI
0088EE  2                       .ENDMACRO
0088EE  2               .endif
0088EE  2               
0088EE  2                       ;; ---------------------------------------------------------
0088EE  2                       ;; Load a chunk of data in srecord format: see
0088EE  2                       ;;    man srec_motorola
0088EE  2                       ;; Only rudimentary error handling and consistency checking
0088EE  2                       ;;
0088EE  2                       ;; May or may not implement the RUN type of record
0088EE  2                       ;; (we begin with the minimum: S1 records)
0088EE  2                       ;;
0088EE  2                       ;; Typical minimal srecord input:
0088EE  2                       ;;   S123204065640DEA204F20446F6E65210DEA606885F66885F79848A000F00320E3FFE6F617
0088EE  2                       ;;   S1122060D002E6F7B1F6C9EAD0F168A86CF60031
0088EE  2                       ;; (lines up to 74 characters, 10 chars of overhead, that's max 32 bytes of payload)
0088EE  2                       ;;
0088EE  2                       ;; S1 Format is a data packet with a 16-bit address
0088EE  2                       ;;   <whitespace>
0088EE  2                       ;;   <line end>
0088EE  2                       ;;   Sn     where n=1
0088EE  2                       ;;   LL     two hex chars of length: number of bytes in remainder of this record
0088EE  2                       ;;   AAAA   four hex chars of address
0088EE  2                       ;;   BB<*>  many pairs of hex chars, the data to be stored
0088EE  2                       ;;   CC     two hex chars, a checksum
0088EE  2                       ;;   <line end>
0088EE  2                       ;;   <whitespace>
0088EE  2                       ;;
0088EE  2                       ;; ---------------------------------------------------------
0088EE  2               
0088EE  2               
0088EE  2               	.DEFINE		PZ_SREC_BUFFLO	$A8
0088EE  2               	.DEFINE		PZ_SREC_BUFFHI	$A9
0088EE  2               	.DEFINE		PZ_SREC_LEN	$AA  ;; the max length, and then the actual length
0088EE  2               	.DEFINE		PZ_SREC_MINASC  $AB
0088EE  2               	.DEFINE		PZ_SREC_MAXASC	$AC
0088EE  2               
0088EE  2               	.DEFINE		SREC_BUFF	$1600	;; $0600 is use by basic as a string buffer
0088EE  2               
0088EE  2               SRECORD:
0088EE  2  20 17 85             JSR PRNTSTR
0088F1  2  57 61 69 74          .BYTE "Waiting for srecord input...", $0D
0088F5  2  69 6E 67 20  
0088F9  2  66 6F 72 20  
00890E  2  EA                   NOP
00890F  2               
00890F  2               SRECORDonemore:
00890F  2  A9 00        	LDA #<SREC_BUFF
008911  2  85 A8        	STA PZ_SREC_BUFFLO
008913  2  A9 16        	LDA #>SREC_BUFF
008915  2  85 A9        	STA PZ_SREC_BUFFHI
008917  2  A9 4C        	LDA #76
008919  2  85 AA        	STA PZ_SREC_LEN
00891B  2  A9 30        	LDA #'0'
00891D  2  85 AB        	STA PZ_SREC_MINASC
00891F  2  A9 53        	LDA #'S'
008921  2  85 AC        	STA PZ_SREC_MAXASC
008923  2               
008923  2  A9 00                LDA #0
008925  2  A2 A8        	LDX #PZ_SREC_BUFFLO
008927  2  A0 00        	LDY #0
008929  2  20 F1 FF     	JSR OSWORD            ;; read a line into $0600
00892C  2               
00892C  2  90 0C        	BCC notescape
00892E  2               
00892E  2  20 17 85             JSR PRNTSTR
008931  2  45 73 63 61  	.BYTE "Escape", $0D
008935  2  70 65 0D     
008938  2  EA                   NOP
008939  2  60                   RTS
00893A  2               
00893A  2               
00893A  2               notescape:
00893A  2  84 AA        	STY PZ_SREC_LEN		;;
00893C  2  A0 00        	LDY #0			;; Y indexes into the srecord in the buffer
00893E  2               
00893E  2  A9 53        	LDA #'S'
008940  2  D9 00 16     	CMP SREC_BUFF,Y
008943  2  D0 22                BNE badformat
008945  2  C8           	INY
008946  2  A9 31        	LDA #'1'
008948  2  D9 00 16     	CMP SREC_BUFF,Y
00894B  2  D0 1A                BNE badformat
00894D  2  C8           	INY			;; advance to the first char of the length
00894E  2               
00894E  2  A2 00        	LDX #0			;; X indexes into the decoded data
008950  2               
008950  2               read3bytes:
008950  2  20 C2 89     	JSR read2hex
008953  2  B0 12        	BCS badformat
008955  2  9D 00 16     	STA SREC_BUFF,X		;; re-use the buffer for the binary data
008958  2  E8           	INX
008959  2  E0 03        	CPX #3			;; we wanted to read LL and AAAA
00895B  2  D0 F3        	BNE read3bytes
00895D  2               
00895D  2  BD FD 15     	LDA SREC_BUFF-3,X	;; the number of bytes left according to the srecord
008960  2  1A           	INC
008961  2  1A           	INC
008962  2  0A           	ASL
008963  2  C5 AA        	CMP PZ_SREC_LEN		;; the line length according to OSWORD
008965  2  F0 10        	BEQ readNbytes
008967  2               
008967  2               badformat:
008967  2  20 17 85             JSR PRNTSTR
00896A  2  42 61 64 20  	.BYTE "Bad format", $0D
00896E  2  66 6F 72 6D  
008972  2  61 74 0D     
008975  2  EA                   NOP
008976  2  60                   RTS
008977  2               
008977  2               
008977  2               readNbytes:
008977  2  20 C2 89     	JSR read2hex
00897A  2  B0 EB        	BCS badformat
00897C  2  9D 00 16     	STA SREC_BUFF,X		;; re-use the buffer for the binary data
00897F  2  E8           	INX
008980  2  C4 AA        	CPY PZ_SREC_LEN		;; compare to end of string
008982  2  D0 F3        	BNE readNbytes
008984  2               
008984  2               	;; we need to verify the checksum
008984  2  86 AA        	STX PZ_SREC_LEN	     	 ;; this length is now a byte count
008986  2  A0 00        	LDY #0
008988  2  A9 00        	LDA #0
00898A  2  18           	CLC
00898B  2               checknext:
00898B  2  79 00 16     	ADC SREC_BUFF,Y
00898E  2  C8           	INY
00898F  2  C4 AA        	CPY PZ_SREC_LEN
008991  2  D0 F8        	BNE checknext
008993  2  1A           	INC
008994  2  F0 12        	BEQ blockmove
008996  2               
008996  2  20 17 85             JSR PRNTSTR
008999  2  42 61 64 20  	.BYTE "Bad checksum", $0D
00899D  2  63 68 65 63  
0089A1  2  6B 73 75 6D  
0089A6  2  EA                   NOP
0089A7  2  60                   RTS
0089A8  2               
0089A8  2               
0089A8  2               	;; finally, we block move the valid data to the target location
0089A8  2               	;; there are assumptions here that addresses are 2 bytes
0089A8  2               	;; so this can't be re-used for S2 records with 24-bit addresses
0089A8  2               blockmove:
0089A8  2  AD 02 16     	LDA SREC_BUFF+2
0089AB  2  85 A8        	STA PZ_SREC_BUFFLO
0089AD  2  AD 01 16     	LDA SREC_BUFF+1
0089B0  2  85 A9        	STA PZ_SREC_BUFFHI
0089B2  2  88           	DEY			;; Y was pointing just past the checksum byte
0089B3  2  88           	DEY
0089B4  2  88           	DEY
0089B5  2  88           	DEY
0089B6  2  88           	DEY
0089B7  2               blockmovenext:
0089B7  2  B9 03 16     	LDA SREC_BUFF+3,Y
0089BA  2  91 A8        	STA (PZ_SREC_BUFFLO),Y
0089BC  2  88           	DEY
0089BD  2  10 F8        	BPL blockmovenext	;; we know the max Y is never more than 32
0089BF  2               
0089BF  2  4C 0F 89     	JMP SRECORDonemore
0089C2  2               	; done - the only exit is to quit or read a bad record
0089C2  2               	; which gets fixed when we deal with S5 or S6 count records, or S8 or S9 execute records
0089C2  2               
0089C2  2                       .ifndef PRNTSTR
0089C2  2                       ;; ----------------------------------------------------------------------
0089C2  2                       ;; Print inline text up to NOP
0089C2  2                       ;; zero page usage: F6 and F7
0089C2  2                       ;; ----------------------------------------------------------------------
0089C2  2               PRNTSTR:
0089C2  2                       PLA
0089C2  2                       STA $F6
0089C2  2                       PLA
0089C2  2                       STA $F7                 ;Pop return address to &F6/7
0089C2  2                       TYA
0089C2  2                       PHA
0089C2  2                       LDY #$00
0089C2  2                       BEQ PRNTSTRBGN
0089C2  2               PRNTSTRNXT:
0089C2  2                       JSR OSASCI
0089C2  2               PRNTSTRBGN:
0089C2  2                       INC $F6
0089C2  2                       BNE PRNTSTRSKP
0089C2  2                       INC $F7                 ; Increment address
0089C2  2               PRNTSTRSKP:
0089C2  2                       LDA ($F6),Y             ; Get character
0089C2  2                       CMP #$EA
0089C2  2                       BNE PRNTSTRNXT          ; If not 'NOP' opcode, loop to print it
0089C2  2                       PLA
0089C2  2                       TAY
0089C2  2                       JMP ($00F6)             ; Pop Y and jump back to code
0089C2  2                       .endif
0089C2  2               
0089C2  2                       ;; Read two hex bytes from a string, return in A
0089C2  2                       ;;   derived from code to parse hex args (c) Gordon Horsington from his Module09 file
0089C2  2               	;; C=0 for success, C=1 for failure
0089C2  2               
0089C2  2               
0089C2  2               read2hex:
0089C2  2  B9 00 16     	LDA SREC_BUFF,Y
0089C5  2  20 E1 89     	JSR hexread1
0089C8  2  90 01        	BCC readmore
0089CA  2  60           	RTS
0089CB  2               readmore:
0089CB  2  0A           	ASL
0089CC  2  0A           	ASL
0089CD  2  0A           	ASL
0089CE  2  0A           	ASL
0089CF  2  99 00 16     	STA SREC_BUFF,Y	;; temp reuse the buffer for upper nibble
0089D2  2  C8           	INY
0089D3  2  B9 00 16     	LDA SREC_BUFF,Y
0089D6  2  20 E1 89     	JSR hexread1
0089D9  2  90 01        	BCC readmore2
0089DB  2  60           	RTS
0089DC  2               
0089DC  2               readmore2:
0089DC  2  19 FF 15     	ORA SREC_BUFF-1,Y	;; result in A
0089DF  2  C8           	INY		;; point to the next char to be read
0089E0  2  60           	RTS
0089E1  2               
0089E1  2               hexread1:
0089E1  2  C9 3A                CMP #$3A      ; ASC("9")+1
0089E3  2  B0 08                BCS hexletters
0089E5  2  C9 30                CMP #$30      ; ASC("0")
0089E7  2  30 0F                BMI hexerr
0089E9  2  29 0F                AND #$F
0089EB  2  18                   CLC
0089EC  2  60                   RTS
0089ED  2               hexletters:
0089ED  2  E9 37                SBC #$37
0089EF  2  C9 0A                CMP #$A
0089F1  2  30 05                BMI hexerr
0089F3  2  C9 10                CMP #$10
0089F5  2  29 0F        	AND #$F
0089F7  2  60                   RTS		; carry will be set if out of range
0089F8  2               hexerr:
0089F8  2  38                   SEC           ; indicate failure to caller
0089F9  2  60                   RTS
0089FA  2               
0089FA  2               
0089FA  2               
0089FA  1               .endif
0089FA  1               
